[{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/flask/","section":"Tags","summary":"","title":"Flask","type":"tags"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/macosm1/","section":"Tags","summary":"","title":"MacOSM1","type":"tags"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/categories/python/","section":"分類","summary":"","title":"python","type":"categories"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/","section":"小瑜的部落格","summary":"","title":"小瑜的部落格","type":"page"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/categories/","section":"分類","summary":"","title":"分類","type":"categories"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":"前言 # 在 macOS M1（Apple Silicon） 上運行 Docker 可能會遇到與傳統 x86 架構不同的挑戰，例如需要特定的架構支援。本篇文章將介紹如何使用 Docker 部署 Flask 應用程式，並逐步解析 Dockerfile 的內容，確保其可在 macOS M1 上順利運行。\n一、建立 Dockerfile # 我們將使用 Docker 來封裝一個簡單的 Flask 應用程式，並確保它能夠在 macOS M1（ARM64 架構） 上正常運行。\n1.1 Dockerfile 內容 # # 適用於 macOS M1 FROM --platform=linux/arm64 python:3.9 # 設定工作目錄 WORKDIR /app # 複製所有檔案到工作目錄 COPY . . # 安裝 Flask RUN pip install --no-cache-dir flask # 開啟 Flask 服務 CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 二、Dockerfile 解析 # 2.1 指定基礎映像與架構 # FROM --platform=linux/arm64 python:3.9 這一行指定了 Python 3.9 作為基礎映像，並明確指定 arm64 平台，確保在 macOS M1（Apple Silicon） 上運行時，不會下載與 ARM 架構不相容的 x86 版本。\n2.2 設定工作目錄 # WORKDIR /app 這行指令設定容器內的工作目錄為 /app，確保所有操作（如 COPY 和 RUN）都在該目錄內執行，提高可維護性。\n2.3 複製專案文件 # COPY . . 第一個 .：代表本機端的當前目錄。 第二個 .：代表容器內的 /app 目錄。 這樣可以確保 app.py 和相關文件成功複製到容器內。\n2.4 安裝 Flask # RUN pip install --no-cache-dir flask 這行指令負責安裝 Flask，並確保不會在 Docker 鏡像中留下安裝快取，減少最終映像的大小。\n2.5 設定容器啟動命令 # CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] 這行設定了容器啟動後執行的預設命令，即 運行 app.py 啟動 Flask 伺服器。\n注意：CMD 只能在 Dockerfile 中出現一次，否則後面的 CMD 會覆蓋前一個。\n三、建置與運行容器 # 3.1 建立 Docker 映像 # 執行以下指令來建立 Docker 映像：\ndocker build -t my-flask-app . -t my-flask-app：指定映像名稱為 my-flask-app。 .：代表 Dockerfile 所在的目錄（當前目錄）。 3.2 運行 Docker 容器 # 執行以下指令來啟動 Flask 應用程式：\ndocker run -p 5000:5000 my-flask-app -p 5000:5000：將容器內的 5000 埠 映射到本機端的 5000 埠，這樣可以透過 http://localhost:5000 訪問 Flask 服務。 my-flask-app：指定要運行的映像名稱。 3.3 確認 Flask 服務運行 # 如果一切正常，終端機應該會顯示 Flask 伺服器正在運行，並且可以開啟瀏覽器訪問：\nhttp://localhost:5000 提示：如果發生錯誤，請確保 app.py 存在，且 Flask 已安裝成功。\n四、結論 # 透過本篇文章，我們學習了如何在 macOS M1 上使用 Docker 部署 Flask 應用程式，並解析了 Dockerfile 的每個步驟。\n回顧學習重點 # FROM --platform=linux/arm64 python:3.9 確保與 macOS M1 相容。 WORKDIR /app 設定工作目錄，方便管理文件。 COPY . . 將專案文件複製到容器內。 RUN pip install --no-cache-dir flask 安裝 Flask。 CMD [\u0026quot;python\u0026quot;, \u0026quot;app.py\u0026quot;] 啟動 Flask 應用程式。 docker build -t my-flask-app . 建立映像。 docker run -p 5000:5000 my-flask-app 啟動 Flask 服務。 這些步驟不僅適用於 Flask，也可以用來封裝其他 Python 應用程式，讓你在 macOS M1 上輕鬆部署自己的應用！🚀\n","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/posts/%E4%BD%BF%E7%94%A8-docker-%E9%81%8B%E8%A1%8C-flask/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在 \u003cstrong\u003emacOS M1（Apple Silicon）\u003c/strong\u003e 上運行 Docker 可能會遇到與傳統 x86 架構不同的挑戰，例如需要特定的架構支援。本篇文章將介紹如何使用 \u003cstrong\u003eDocker\u003c/strong\u003e 部署 Flask 應用程式，並逐步解析 \u003ccode\u003eDockerfile\u003c/code\u003e 的內容，確保其可在 \u003cstrong\u003emacOS M1\u003c/strong\u003e 上順利運行。\u003c/p\u003e","title":"在 macOS M1 上使用 Docker 運行 Flask 應用程式","type":"posts"},{"content":"","date":"5 February 2025","externalUrl":null,"permalink":"/douoduublog/categories/%E8%BB%9F%E9%AB%94%E6%95%99%E5%AD%B8/","section":"分類","summary":"","title":"軟體教學","type":"categories"},{"content":"","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/series/selemium%E7%88%AC%E5%8F%96youtube%E6%A8%99%E9%A1%8C/","section":"Series","summary":"","title":"Selemium爬取Youtube標題","type":"series"},{"content":"","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/selenium/","section":"Tags","summary":"","title":"Selenium","type":"tags"},{"content":"前言 # Selenium 中的導航與元素選取，包括 driver.back()、driver.forward()、WebDriverWait 及 XPath 。\n在這篇文章中，我們將使用 Selenium 來搜尋 YouTube 上的比特幣相關影片，並詳細解析 網頁導航 與 元素選取 的關鍵函式。\n包括：\ndriver.back() 與 driver.forward() 用於瀏覽器導航 time.sleep(5) 控制頁面載入時間 XPath 語法來選取特定元素，如 first_video = driver.find_element(By.XPATH, '(//a[@id=\u0026quot;video-title\u0026quot;])[1]') WebDriverWait(driver, 10).until(EC.presence_of_element_located(...)) 來確保元素已經載入 一、完整程式碼 # from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.keys import Keys import selenium from selenium.webdriver.common.by import By from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC import time # 設定 ChromeDriver 路徑 PATH = \u0026#34;/Users/doudouu0504/Desktop/chromedriver-mac-arm64/chromedriver\u0026#34; driver = webdriver.Chrome(service=Service(PATH)) driver.get(\u0026#34;https://www.youtube.com/\u0026#34;) # 搜尋關鍵字 \u0026#34;比特幣\u0026#34; search = driver.find_element(By.NAME, \u0026#34;search_query\u0026#34;) search.clear() search.send_keys(\u0026#34;比特幣\u0026#34;) search.send_keys(Keys.RETURN) # 等待搜尋結果載入 WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.XPATH, \u0026#39;//a[@id=\u0026#34;video-title\u0026#34;]\u0026#39;)) ) # 取得所有搜尋結果的標題 titles = driver.find_elements(By.XPATH, \u0026#39;//a[@id=\u0026#34;video-title\u0026#34;]\u0026#39;) for title in titles: print(title.text) # 選取第一個搜尋結果 first_video = driver.find_element(By.XPATH, \u0026#39;(//a[@id=\u0026#34;video-title\u0026#34;])[1]\u0026#39;) print(\u0026#34;即將點擊影片:\u0026#34;, first_video.text) first_video.click() # 等待影片載入 time.sleep(5) # 返回上一頁 driver.back() time.sleep(2) # 等待返回頁面載入 # 前進至影片頁面 driver.forward() time.sleep(2) # 等待前進頁面載入 input(\u0026#34;按 Enter 鍵結束程式並關閉瀏覽器...\u0026#34;) driver.quit() 二、程式碼解析 # 2.1 WebDriverWait(driver, 10).until(\u0026hellip;) # 這段程式碼確保搜尋結果已經載入，避免 find_element 找不到元素導致錯誤：\nWebDriverWait(driver, 10).until( EC.presence_of_element_located((By.XPATH, \u0026#39;//a[@id=\u0026#34;video-title\u0026#34;]\u0026#39;)) ) WebDriverWait(driver, 10): 最多等待 10 秒。 EC.presence_of_element_located((By.XPATH, '//a[@id=\u0026quot;video-title\u0026quot;]')): 確認該元素已經出現在 DOM 中，但不一定可見。 2.2 driver.find_element() # 這行程式碼選取 第一個搜尋結果 並印出其標題：\n當我們打開 YouTube 搜尋結果頁面，按下 F12 進入開發者工具，使用 Elements 檢視網頁的 HTML 結構時，可以發現影片標題的連結 \u0026lt;a\u0026gt; 元素具有 id=\u0026quot;video-title\u0026quot;，這表示我們可以透過 XPath //a[@id=\u0026quot;video-title\u0026quot;] 來選取所有影片標題。\nfirst_video = driver.find_element(By.XPATH, \u0026#39;(//a[@id=\u0026#34;video-title\u0026#34;])[1]\u0026#39;) print(\u0026#34;即將點擊影片:\u0026#34;, first_video.text) (//a[@id=\u0026quot;video-title\u0026quot;])[1]：選取 第一個影片標題連結。 print(first_video.text)：顯示影片標題，讓使用者確認即將點擊的內容。 這樣的 XPath 表達式能幫助我們鎖定 YouTube 影片搜尋結果中的第一個影片，確保自動化腳本能夠點擊正確的影片。\n2.3 driver.back() 與 driver.forward() # 這兩行程式碼負責 模擬瀏覽器的返回與前進操作：\ndriver.back() time.sleep(2) # 等待返回頁面載入 driver.forward() time.sleep(2) # 等待前進頁面載入 driver.back()：返回上一頁（搜尋結果頁）。 time.sleep(2)：等待頁面載入完成。 driver.forward()：前進到影片播放頁面。 提示：time.sleep() 是強制等待，較佳做法是使用 WebDriverWait 確保頁面載入。\n三、結論 # 這篇文章示範了如何使用 Selenium 自動搜尋 YouTube 影片，並解析了幾個重要的功能：\nWebDriverWait(driver, 10).until(...) 確保搜尋結果已載入。 first_video = driver.find_element(By.XPATH, '(//a[@id=\u0026quot;video-title\u0026quot;])[1]') 選取第一個搜尋結果。 driver.back() 與 driver.forward() 用於網頁導航。 time.sleep(5) 等待頁面載入，但可用 WebDriverWait 優化。 這些技術對於爬蟲開發與自動化測試都十分重要，建議讀者可以進一步嘗試不同的關鍵字搜尋，或結合其他 Selenium 方法來提升爬取效率。\n","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/posts/selenium-%E6%93%8D%E4%BD%9C-youtube%E8%A7%A3%E6%9E%90%E5%B0%8E%E8%88%AA%E8%88%87%E5%85%83%E7%B4%A0%E9%81%B8%E5%8F%96/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eSelenium 中的導航與元素選取，包括 driver.back()、driver.forward()、WebDriverWait 及 XPath 。\u003cbr\u003e\n在這篇文章中，我們將使用 \u003ccode\u003eSelenium\u003c/code\u003e 來搜尋 YouTube 上的比特幣相關影片，並詳細解析 \u003cstrong\u003e網頁導航\u003c/strong\u003e 與 \u003cstrong\u003e元素選取\u003c/strong\u003e 的關鍵函式。\u003c/p\u003e","title":"Selenium 操作 YouTube：解析導航與元素選取","type":"posts"},{"content":"","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/tags/%E7%88%AC%E8%9F%B2/","section":"Tags","summary":"","title":"爬蟲","type":"tags"},{"content":"前言 # 在這篇文章中，我將分享如何使用 Selenium 自動搜尋 YouTube 影片，並抓取搜尋結果的影片標題。這對於數據分析、內容整理，甚至是自動化工具開發都相當有幫助。\n一、環境準備 # 如果你想瞭解如何安裝 Selenium 以及下載對應的 ChromeDriver，可以參考我的另一篇文章：使用 Poetry 安裝 Selenium 並下載 ChromeDriver。\n二、程式碼解析 # 2.1 完整程式碼 # 以下是完整的 Python 程式碼，負責開啟 YouTube，輸入關鍵字 \u0026ldquo;比特幣\u0026rdquo;，並列出搜尋結果中的影片標題。\nfrom selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.keys import Keys import selenium from selenium.webdriver.common.by import By from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # 設定 ChromeDriver 路徑 PATH = \u0026#34;/Users/doudouu0504/Desktop/chromedriver-mac-arm64/chromedriver\u0026#34; # 建立 WebDriver 物件 if selenium.__version__.startswith(\u0026#34;4\u0026#34;): driver = webdriver.Chrome(service=Service(PATH)) else: driver = webdriver.Chrome(executable_path=PATH) # 開啟 YouTube driver.get(\u0026#34;https://www.youtube.com/\u0026#34;) # 找到搜尋框並輸入關鍵字 search = driver.find_element(By.NAME, \u0026#34;search_query\u0026#34;) search.send_keys(\u0026#34;比特幣\u0026#34;) search.send_keys(Keys.RETURN) # 等待搜尋結果載入 WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, \u0026#34;container\u0026#34;))) # 取得影片標題 titles = driver.find_elements(By.ID, \u0026#34;video-title\u0026#34;) for title in titles: print(title.text) # 保持瀏覽器開啟，等待使用者按 Enter 鍵結束 input(\u0026#34;按 Enter 鍵結束程式並關閉瀏覽器...\u0026#34;) driver.quit() 三、程式碼說明 # 3.1 啟動 WebDriver # 程式會根據 Selenium 版本來決定 webdriver.Chrome() 的呼叫方式，確保相容性。\n3.2 開啟 YouTube 並搜尋關鍵字 # 使用 driver.get() 方法開啟 YouTube，然後透過 find_element(By.NAME, \u0026quot;search_query\u0026quot;) 找到搜尋框，並輸入 \u0026ldquo;比特幣\u0026rdquo;，最後使用 send_keys(Keys.RETURN) 執行搜尋。\n3.3 等待搜尋結果載入 # 使用 WebDriverWait 確保搜尋結果已載入，避免 find_elements 執行時找不到目標元素。\nWebDriverWait(driver, 10): 設定等待時間最長 10 秒。 until(EC.presence_of_element_located((By.ID, \u0026quot;container\u0026quot;))): 直到 ID 為 container 的元素出現才繼續執行。 其他條件如： visibility_of_element_located(locator): 確保元素可見。 element_to_be_clickable(locator): 確保元素可被點擊。 3.4 取得影片標題 # 使用 find_elements(By.ID, \u0026quot;video-title\u0026quot;) 找到所有影片標題並印出。\n四、注意事項 # 4.1 ChromeDriver 版本 # 請確保 Chrome 瀏覽器與 chromedriver 版本相符，否則可能會出錯。\n4.2 YouTube 限制 # YouTube 可能會檢測機器人行為，建議適當調整 WebDriverWait 來模擬人類操作。\n五、結論 # 這篇文章介紹了如何使用 Selenium 自動化 YouTube 搜尋與爬取影片標題的方式，適合用於研究熱門關鍵字或是建立個人化的影片推薦系統。\n","date":"1 February 2025","externalUrl":null,"permalink":"/douoduublog/posts/%E4%BD%BF%E7%94%A8-selenium-%E8%87%AA%E5%8B%95%E5%8C%96-youtube-%E6%90%9C%E5%B0%8B%E8%88%87%E7%88%AC%E5%8F%96%E5%BD%B1%E7%89%87%E6%A8%99%E9%A1%8C/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在這篇文章中，我將分享如何使用 \u003ccode\u003eSelenium\u003c/code\u003e 自動搜尋 YouTube 影片，並抓取搜尋結果的影片標題。這對於數據分析、內容整理，甚至是自動化工具開發都相當有幫助。\u003c/p\u003e","title":"使用 Selenium 自動化 YouTube 搜尋與爬取影片標題","type":"posts"},{"content":"","date":"31 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/poetry/","section":"Tags","summary":"","title":"Poetry","type":"tags"},{"content":"前言 # 在這篇文章中，我將介紹如何使用 Poetry 來管理 Python 環境，並安裝 Selenium 以進行網頁自動化測試。此外，我們也會下載並設定 ChromeDriver，使其能夠與 Selenium 搭配運行。\n一、安裝與初始化 Poetry # 1.1 安裝 Poetry（若尚未安裝） # 如果你還沒有安裝 Poetry，可以使用以下指令來安裝：\ncurl -sSL https://install.python-poetry.org | python3 - 安裝完成後，使用以下指令確認是否成功安裝：\npoetry --version 1.2 初始化 Poetry 專案 # 使用以下指令來初始化一個新的 Poetry 專案：\npoetry init 這個指令會引導你輸入一些專案資訊（名稱、版本、描述等），你可以根據需求填寫，或直接按 Enter 跳過。\n二、啟動虛擬環境並安裝 Selenium # 2.1 啟動虛擬環境 # 在 Poetry 初始化完成後，使用以下指令進入虛擬環境：\npoetry shell 2.2 安裝 Selenium # 安裝 Selenium 並將其記錄到 pyproject.toml 內，確保環境的可重現性：\npoetry add selenium 三、下載並設定 ChromeDriver # 3.1 確認 Chrome 版本 # 開啟 Chrome 瀏覽器。 在網址列輸入： chrome://settings/help 記下 Chrome 的版本號，例如 120.0.6099.129。 3.2 下載 ChromeDriver # 前往 Chrome for Testing 官方網站，下載與你的 Chrome 版本相符的 chromedriver。\nApple Silicon (M1/M2/M3)：下載 chromedriver-mac-arm64.zip Intel Mac：下載 chromedriver-mac-x64.zip 3.3 解壓縮並設定 ChromeDriver # 下載後，打開終端機並輸入以下指令來解壓縮：\ncd ~/Downloads unzip chromedriver-mac-arm64.zip -d ~/Desktop/ 確保它有執行權限：\nchmod +x ~/Desktop/chromedriver 四、撰寫 Selenium 測試程式 # 4.1 開啟瀏覽器 # 建立一個 practice.py，並寫入以下程式碼來開啟一個空白的 Chrome 瀏覽器：\nfrom selenium import webdriver from selenium.webdriver.chrome.service import Service import selenium PATH = \u0026#34;/Users/doudouu0504/Desktop/chromedriver\u0026#34; driver = webdriver.Chrome(service=Service(PATH)) driver.get(\u0026#34;about:blank\u0026#34;) input(\u0026#34;按 Enter 鍵以結束程式並關閉瀏覽器...\u0026#34;)#這樣頁面就不會一閃而過 driver.quit() 4.2 執行測試 # 執行程式：\npython practice.py 如果沒有錯誤，則表示你的 Selenium 和 ChromeDriver 都已成功安裝！\n請記得要在終端機按下 Enter 鍵，不然會一直開著瀏覽器。\n五、抓取網頁標題 # 5.1 撰寫抓取標題程式碼 # 如果你想要抓取某個網頁的標題，例如 Dcard 首頁，可以使用以下程式碼：\nfrom selenium import webdriver from selenium.webdriver.chrome.service import Service import selenium PATH = \u0026#34;/Users/doudouu0504/Desktop/chromedriver\u0026#34; driver = webdriver.Chrome(service=Service(PATH)) driver.get(\u0026#34;https://www.dcard.tw/f\u0026#34;) print(driver.title) # input(\u0026#34;按 Enter 鍵以結束程式並關閉瀏覽器...\u0026#34;) driver.quit() 5.2 執行並驗證 # 執行後，終端機應該會顯示 Dcard 的標題。\n提示：input(\u0026quot;按 Enter 鍵以結束程式並關閉瀏覽器...\u0026quot;) 這一行可以選擇性保留，當你希望手動關閉瀏覽器時才使用。\n六、結論 # 透過 Poetry，我們可以方便地管理 Python 專案的環境與依賴，而 Selenium 則讓我們能夠輕鬆地自動化操作網頁。此外，我們學習了如何下載並解壓縮 ChromeDriver 到桌面，並使用 Selenium 來抓取網頁標題。\n希望這篇文章能幫助你順利完成 Selenium 的安裝與測試！\n","date":"31 January 2025","externalUrl":null,"permalink":"/douoduublog/posts/%E4%BD%BF%E7%94%A8-poetry-%E5%AE%89%E8%A3%9D-selenium-%E4%B8%A6%E4%B8%8B%E8%BC%89-chromedriver/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在這篇文章中，我將介紹如何使用 Poetry 來管理 Python 環境，並安裝 Selenium 以進行網頁自動化測試。此外，我們也會下載並設定 ChromeDriver，使其能夠與 Selenium 搭配運行。\u003c/p\u003e","title":"使用 Poetry 安裝 Selenium 並下載 ChromeDriver","type":"posts"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/django/","section":"Tags","summary":"","title":"Django","type":"tags"},{"content":"前言 # 本文將詳細講解如何在 Django 中實現忘記密碼功能，並完整演示 Gmail SMTP 配置的每一步驟，幫助您快速部署信件服務。這個功能會利用 Gmail 作為信件伺服，並使用 Google 應用專用密碼進行伺服器帳號的登入串接。\nSMTP 解說 # 此篇文章是使用 SMTP（Simple Mail Transfer Protocol）來實現電子郵件功能的應用。SMTP 是一種傳送電子郵件的通訊協議。在這個實現中，我們使用了 Gmail 的 SMTP 服務，通過 Django 的內建郵件後端將密碼重置相關的電子郵件發送給用戶。\n具體來說，這裡的設定包括：\n使用 Gmail 的 SMTP 服務器 (smtp.gmail.com)。 啟用 TLS 加密（在 587 端口上）來保護傳輸過程。 使用 Google 的應用專用密碼（EMAIL_HOST_PASSWORD）來進行身份驗證。 SMTP 是這個功能的基礎協議，而 Google 應用專用密碼確保了 Gmail 賬戶的安全性，因為它允許您在不暴露主密碼的情況下為特定應用生成專用密碼。\n一、Django 忘記密碼功能完整教學（包含 SMTP 配置指南） # 1.1 設定 Google 應用專用密碼 # 在使用 Gmail 發送信件前，您需要在 Google 帳號中生成應用專用密碼：\n前往 Google 安全設定 \u0026gt; 啟用 \u0026ldquo;電子郵件的入口\u0026quot;功能。 完成驗證後，向下捲動到 \u0026ldquo;應用程式密碼\u0026rdquo; 區域，點選 \u0026ldquo;生成密碼\u0026rdquo;。（也可以在搜尋欄搜尋關鍵字） 選擇應用類型為 \u0026ldquo;電子郵件\u0026rdquo; 和製備字軟體為 \u0026ldquo;同步電子郵件\u0026rdquo; 。 輸入應用程式名稱，會生成一組密碼請記住它。 將生成的密碼填入 .env 檔案進行版控。 1.2 專案設置 # 在 settings.py 配置 Django 的 Gmail SMTP 信件服務：\nimport os from dotenv import load_dotenv # 設置 Gmail 發送信件 EMAIL_BACKEND = \u0026#34;django.core.mail.backends.smtp.EmailBackend\u0026#34; # 使用 SMTP 服務發送郵件 EMAIL_HOST = \u0026#34;smtp.gmail.com\u0026#34; # 指定 Gmail SMTP 服務器 EMAIL_PORT = 587 # Gmail SMTP 使用的端口 EMAIL_USE_TLS = True # 啟用 TLS 加密 EMAIL_USE_SSL = False # 不使用 SSL 加密 EMAIL_HOST_USER = os.getenv(\u0026#34;EMAIL_HOST_USER\u0026#34;) # Gmail 地址 EMAIL_HOST_PASSWORD = os.getenv(\u0026#34;EMAIL_HOST_PASSWORD\u0026#34;) # Gmail 密碼 DEFAULT_FROM_EMAIL = \u0026#34;三合平台 \u0026lt;youremail@gmail.com\u0026gt;\u0026#34; # 指定基礎域名 # 替換 `DEFAULT_DOMAIN` 和 `PROTOCOL` 為您的開發環境 DEFAULT_DOMAIN = os.getenv(\u0026#34;DEFAULT_DOMAIN\u0026#34;, \u0026#34;localhost:8000\u0026#34;) PROTOCOL = os.getenv(\u0026#34;PROTOCOL\u0026#34;, \u0026#34;http\u0026#34;) LANGUAGE_CODE = \u0026#34;zh-hant\u0026#34; #設置為中文 EMAIL_HOST_USER 與 EMAIL_HOST_PASSWORD已經接受版本控制，.env 內容前者為您的 Email，後者為 Gmail 提供給您的密碼。 DEFAULT_DOMAIN與PROTOCOL，在測試環境下，基礎設置，.env 內容前者為 127.0.0.1:8000，後者為 http。 .env 檔案的範例：\nEMAIL_HOST_USER=your_email@gmail.com\nEMAIL_HOST_PASSWORD=your_app_password\nDEFAULT_DOMAIN=127.0.0.1:8000\n二、使用路徑與設計觀念 # 忘記密碼功能依賴 Django 的內建功能，包括了以下路由和觀念實現：\n2.2 配置 URLs # 在 users/urls.py 中配置相關路由：\nfrom .views import ( CustomPasswordResetView, CustomPasswordResetDoneView, CustomPasswordResetConfirmView, CustomPasswordResetCompleteView, ) urlpatterns = [ path(\u0026#34;password_reset/\u0026#34;, CustomPasswordResetView.as_view(), name=\u0026#34;password_reset\u0026#34;), path(\u0026#34;password_reset_done/\u0026#34;, CustomPasswordResetDoneView.as_view(), name=\u0026#34;password_reset_done\u0026#34;), path(\u0026#34;reset/\u0026lt;uidb64\u0026gt;/\u0026lt;token\u0026gt;/\u0026#34;, CustomPasswordResetConfirmView.as_view(), name=\u0026#34;password_reset_confirm\u0026#34;), path(\u0026#34;reset_done/\u0026#34;, CustomPasswordResetCompleteView.as_view(), name=\u0026#34;password_reset_complete\u0026#34;), ] 2.3 根目錄的 URL 配置：為 Django 忘記密碼功能設置路徑 # 在根目錄core/urls.py 中增加路徑：\npath(\u0026#34;users/\u0026#34;, include(\u0026#34;users.urls\u0026#34;, namespace=\u0026#34;users\u0026#34;)), 三、定義流程控制 View # 在 users/views.py 執行，以下自定義的 View 內容：\n3.1 CustomPasswordResetView # from django.conf import settings from django.contrib.auth import views as auth_views from django.utils.encoding import force_bytes from django.contrib.auth.tokens import default_token_generator from django.core.mail import EmailMessage from django.template.loader import render_to_string from django.utils.http import urlsafe_base64_encode class CustomPasswordResetView(auth_views.PasswordResetView): template_name = \u0026#34;users/password_reset.html\u0026#34; email_template_name = \u0026#34;users/password_reset_email.html\u0026#34; subject_template_name = \u0026#34;users/password_reset_subject.txt\u0026#34; # 自定義郵件標題模板 success_url = \u0026#34;/users/password_reset_done/\u0026#34; extra_context = { \u0026#34;protocol\u0026#34;: settings.PROTOCOL, \u0026#34;domain\u0026#34;: settings.DEFAULT_DOMAIN, } def form_valid(self, form): \u0026#34;\u0026#34;\u0026#34;覆蓋郵件發送邏輯，避免重複發送\u0026#34;\u0026#34;\u0026#34; email = form.cleaned_data[\u0026#34;email\u0026#34;] for user in form.get_users(email): context = { \u0026#34;email\u0026#34;: email, \u0026#34;domain\u0026#34;: settings.DEFAULT_DOMAIN, \u0026#34;protocol\u0026#34;: settings.PROTOCOL, \u0026#34;uid\u0026#34;: urlsafe_base64_encode(force_bytes(user.pk)), \u0026#34;token\u0026#34;: default_token_generator.make_token(user), } subject = render_to_string(self.subject_template_name, context).strip() html_message = render_to_string(self.email_template_name, context) # 發送郵件 email_msg = EmailMessage( subject=subject, body=html_message, from_email=settings.DEFAULT_FROM_EMAIL, to=[email], ) email_msg.content_subtype = \u0026#34;html\u0026#34; # 設置內容類型為 HTML email_msg.send() # 不再調用的郵件發送邏輯 return super(auth_views.PasswordResetView, self).form_valid(form) 3.2 CustomPasswordResetDoneView # class CustomPasswordResetDoneView(auth_views.PasswordResetDoneView): template_name = \u0026#34;users/password_reset_done.html\u0026#34; 3.3 CustomPasswordResetConfirmView # class CustomPasswordResetConfirmView(auth_views.PasswordResetConfirmView): template_name = \u0026#34;users/password_reset_confirm.html\u0026#34; success_url = \u0026#34;/users/reset_done/\u0026#34; 3.4 CustomPasswordResetCompleteView # class CustomPasswordResetCompleteView(auth_views.PasswordResetCompleteView): template_name = \u0026#34;users/password_reset_complete.html\u0026#34; 四、信件樣板 # 在 users/templates/users 底下，設置以下所有 html 信件樣板\n4.1 點選忘記密碼第一步 # 此為用戶忘記密碼寄件前的說明，讓用戶可以輸入自己的 Email，使得後台可以去做發信的作業，在password_reset.html底下輸入：\n\u0026lt;div class=\u0026#34;flex flex-col items-center justify-center min-h-screen bg-gray-100\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md p-8 bg-white rounded-lg shadow-md\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;mb-4 text-2xl font-semibold text-center text-gray-700\u0026#34;\u0026gt; 忘記密碼？ \u0026lt;/h2\u0026gt; \u0026lt;p class=\u0026#34;mb-6 text-center text-gray-500\u0026#34;\u0026gt; 請輸入您的電子郵件地址，我們將向您發送重置密碼的指示。 \u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; class=\u0026#34;space-y-6\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;div class=\u0026#34;mt-1\u0026#34;\u0026gt;{{ form.as_p }}\u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 發送重置連結 \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-sm text-center text-gray-600\u0026#34;\u0026gt; 記得密碼了嗎？ \u0026lt;a href=\u0026#34;{% url \u0026#39;users:login\u0026#39; %}\u0026#34; class=\u0026#34;text-blue-500 hover:underline\u0026#34; \u0026gt;回到登入頁面\u0026lt;/a \u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4.2 發送信件告知 # 此為告知用戶發送信件了，在password_reset_done.html輸入：\n\u0026lt;div class=\u0026#34;flex flex-col items-center justify-center min-h-screen bg-gray-100\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md p-8 bg-white rounded-lg shadow-md\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;mb-4 text-2xl font-semibold text-center text-gray-700\u0026#34;\u0026gt; 密碼重置連結已發送 \u0026lt;/h2\u0026gt; \u0026lt;p class=\u0026#34;mb-6 text-center text-gray-500\u0026#34;\u0026gt; 我們已經將重置密碼的指示發送到您的電子郵件地址，請檢查您的信箱。 \u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;users:login\u0026#39; %}\u0026#34; class=\u0026#34;block w-full px-4 py-2 text-center text-white bg-blue-500 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 返回登入頁面 \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4.3 發送的信件內容 # 用戶會收到的新建內容，在password_reset_email.html輸入：\n\u0026lt;p\u0026gt;親愛的用戶，您好！這裡是三合接案平台。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 我們收到您重置密碼的申請，為了確保您的帳號安全，請點擊以下連結完成密碼重置： \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;{{ protocol }}://{{ domain }}{% url \u0026#39;users:password_reset_confirm\u0026#39; uidb64=uid token=token %}\u0026#34; style=\u0026#34;color: #007bff; text-decoration: none; font-weight: bold\u0026#34; \u0026gt; 重置密碼 \u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;請注意：該連結僅在一段時間內有效，過期後將無法使用。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;如果您並未發起此操作，請忽略此郵件，無需進行任何操作。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 感謝您使用「三合」接案平台！如有任何疑問或需要幫助，請隨時聯繫我們的客服團隊，我們將竭誠為您服務。 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;祝順利！\u0026lt;br /\u0026gt;三合團隊\u0026lt;/p\u0026gt; 4.4 重置密碼 # 用戶點擊信件內容的「 重置密碼 」後，會需要輸入新的密碼做確認，在password_reset_confirm.html輸入：\n\u0026lt;div class=\u0026#34;flex flex-col items-center justify-center min-h-screen bg-gray-100\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md p-8 bg-white rounded-lg shadow-md\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;mb-4 text-2xl font-semibold text-center text-gray-700\u0026#34;\u0026gt; 重置您的密碼 \u0026lt;/h2\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; class=\u0026#34;space-y-6\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;div class=\u0026#34;space-y-4\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;id_new_password1\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 break-words\u0026#34; \u0026gt; 新密碼：\u0026lt;/label \u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;new_password1\u0026#34; id=\u0026#34;id_new_password1\u0026#34; class=\u0026#34;block w-full px-3 py-2 mt-1 text-gray-700 placeholder-gray-400 bg-white border border- gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm\u0026#34; placeholder=\u0026#34;請輸入新密碼\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;id_new_password2\u0026#34; class=\u0026#34;block text-sm font-medium text-gray-700 break-words\u0026#34; \u0026gt; 新密碼確認：\u0026lt;/label \u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;new_password2\u0026#34; id=\u0026#34;id_new_password2\u0026#34; class=\u0026#34;block w-full px-3 py-2 mt-1 text-gray-700 placeholder-gray-400 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm\u0026#34; placeholder=\u0026#34;請再次輸入新密碼\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-full px-4 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 修改密碼 \u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-sm text-center text-gray-600\u0026#34;\u0026gt; 想起密碼了嗎？ \u0026lt;a href=\u0026#34;{% url \u0026#39;users:login\u0026#39; %}\u0026#34; class=\u0026#34;text-blue-500 hover:underline\u0026#34;\u0026gt; 返回登入頁面 \u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4.4 重置密碼 # 最後完成重置密碼後，會有的完成頁面，增加用戶體驗，在password_reset_complete.html輸入：\n\u0026lt;div class=\u0026#34;flex flex-col items-center justify-center min-h-screen bg-gray-100\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md p-8 bg-white rounded-lg shadow-md\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mb-6 text-2xl font-semibold text-center text-gray-700\u0026#34;\u0026gt; 密碼重置成功 \u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mb-6 text-center text-gray-500\u0026#34;\u0026gt; 您的密碼已經成功重置，您現在可以使用新密碼！ \u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{% url \u0026#39;users:login\u0026#39; %}\u0026#34; class=\u0026#34;inline-block px-6 py-2 text-white bg-blue-500 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 返回登入頁面 \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 4.5 信件標題 # 最後，若是想增加用戶體驗，也可以新增標題，在password_reset_subject.txt輸入：\n三合接案平台：密碼通知 五、主要結構清單 # users/ ├── urls.py ├── views.py ├── templates/ │ ├── users/ │ ├── password_reset.html │ ├── password_reset_done.html │ ├── password_reset_confirm.html │ ├── password_reset_complete.html │ ├── password_reset_subject.txt 六、結論 # 本文完整展示了 Django 忘記密碼功能的實現過程，從 Gmail SMTP 配置到路由設置與信件模板編寫，幫助您快速完成相關功能開發。如需進一步了解，請參考「Django 郵件發送指南」或官方文檔。\n參考文檔：\nDjango 官方文檔\n","date":"8 January 2025","externalUrl":null,"permalink":"/douoduublog/posts/django-%E5%BF%98%E8%A8%98%E5%AF%86%E7%A2%BC%E6%95%99%E5%AD%B8%E4%BD%BF%E7%94%A8-gmail-smtp-%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本文將詳細講解如何在 Django 中實現忘記密碼功能，並完整演示 Gmail SMTP 配置的每一步驟，幫助您快速部署信件服務。這個功能會利用 Gmail 作為信件伺服，並使用 Google 應用專用密碼進行伺服器帳號的登入串接。\u003c/p\u003e","title":"Django 忘記密碼教學：使用 Gmail SMTP 完整配置指南","type":"posts"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/smtp%E5%AF%84%E4%BB%B6%E6%95%99%E5%AD%B8/","section":"Tags","summary":"","title":"SMTP寄件教學","type":"tags"},{"content":"","date":"8 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/%E5%BF%98%E8%A8%98%E5%AF%86%E7%A2%BC%E5%8A%9F%E8%83%BD/","section":"Tags","summary":"","title":"忘記密碼功能","type":"tags"},{"content":"前言 # 金流功能是現代網站必不可少的商業化功能之一。本文中，將指導如何在 Django 框架中經由綠界金流完成支付功能的串接。最終將實現一個包括服務選擇、訂單管理和支付清算的完整流程。\n流程圖 # 一、針對綠界金流進行註冊 # 在開始前，您需要先在綠界金流平台上註冊一個帳號。註冊步驟如下：\n登入綠界金流平台，連結：https://www.ecpay.com.tw/ 點擊頁面上方的「註冊」，填寫您的企業資料和聯絡方式。 透過驗證完成註冊後，登入帳號。 進入管理介面，設定金流網閱連接（如 ReturnURL 和 OrderResultURL）。 在您的帳號中導出 MerchantID、HashKey 和 HashIV，這是金流串接的重要參數。 1.1 測試環境 # 若正在進行開發或測試，可以使用綠界提供的測試環境參數：\nMerchantID: 3002607 HashKey: pwFHCqoQZGmho4w6 HashIV: EkRm7iFT261dpevs ECPay URL: https://payment-stage.ecpay.com.tw/Cashier/AioCheckOut/V5 這些參數為綠界提供的測試用資訊，僅適用於測試環境。正式上線時，請記得切換為綠界提供的正式環境參數。\n二、環境設置與執行步驟 # 在正式進行開發之前，請確保您已完成以下環境設置步驟：\n安裝必要的 Python 套件： pip install django 創建並啟動新的 Django 專案： django-admin startproject myproject . python manage.py startapp order python manage.py startapp services 為什麼需要建立 order 和 services 應用？ # 本專案分享的是一個模仿國外接案平台 Fiverr 的接案平台，主要是一個接案者可以有多個服務方案，每個服務方案有一般方案與專業方案，消費者可以選擇不同的服務方案去下單。\norder 和 services 應用是其核心部分：\norder 負責管理訂單，用戶可以對每個 service 下訂單。 services 用於定義平台上的服務，例如不同的方案（Standard 和 Premium）。\n通過這樣的設計，清晰地將訂單和服務邏輯分開，便於後續維護和擴展。 將應用 order 和 services 添加到 settings.py 中的 INSTALLED_APPS 列表。\n建立資料庫遷移檔並執行遷移：\npython manage.py makemigrations python manage.py migrate 啟動開發伺服器： python manage.py runserver 伺服器啟動後，訪問 http://127.0.0.1:8000 確保項目運行正常。\n三、核心實作解析 # 3.1 路徑需求 # 在 order 應用中，需要在 urls.py 中定義對應的路徑。\norder/urls.py\nfrom django.urls import path from . import views app_name = \u0026#34;order\u0026#34; # 定義應用命名空間 urlpatterns = [ path(\u0026#34;failed/\u0026#34;, views.failed, name=\u0026#34;order_failed\u0026#34;), # 支付失敗頁面 path(\u0026#34;successful/\u0026#34;, views.successful, name=\u0026#34;order_successful\u0026#34;), # 支付成功頁面 path(\u0026#34;create/\u0026#34;, views.create_order, name=\u0026#34;create_order\u0026#34;), # 創建訂單 path(\u0026#34;return/\u0026#34;, views.ecpay_return, name=\u0026#34;ecpay_return\u0026#34;), # 綠界回傳通知處理 path(\u0026#34;result/\u0026#34;, views.ecpay_result, name=\u0026#34;ecpay_result\u0026#34;), # 支付結果頁面 path(\u0026#34;\u0026lt;int:service_id\u0026gt;/\u0026#34;, views.payment_form_select, name=\u0026#34;payment_form_select\u0026#34;), # 選擇方案 ] 在根目錄也別忘了增加路徑。\nmyproject/urls.py\nfrom django.contrib import admin from django.urls import include, path urlpatterns = [ path(\u0026#34;admin/\u0026#34;, admin.site.urls), # 內建 path(\u0026#34;order/\u0026#34;, include(\u0026#34;order.urls\u0026#34;)), # 包含 order 應用的路由 ] 3.2 需要的套件與匯入項目 # 所有核心功能都在 order 應用的 views.py 文件中實作，並需要以下模組的匯入：\nfrom django.shortcuts import render, get_object_or_404, redirect from django.http import JsonResponse, HttpResponse from .models import Order from services.models import Service from django.views.decorators.csrf import csrf_exempt from django.contrib.auth.decorators import login_required from django.conf import settings from datetime import datetime import hashlib import urllib.parse from django.urls import reverse 這些模組用於處理 HTTP 請求、驗證用戶、操作數據庫模型，並生成必要的加密值。\n3.3 設定金流參數與生成驗證碼 # 在 views.py 文件頂部，我們設置了綠界金流所需的參數，從 settings.py 獲取：\nMERCHANT_ID = settings.MERCHANT_ID # 綠界金流的商店代號 HASH_KEY = settings.HASH_KEY # 綠界金流的 Hash Key HASH_IV = settings.HASH_IV # 綠界金流的 Hash IV ECPAY_URL = settings.ECPAY_URL # 綠界金流的支付網址 並實作了一個生成 CheckMacValue 的函數：\ndef generate_check_mac_value(params, hash_key, hash_iv):#定義了一個函數 generate_check_mac_value，用於生成驗證碼。 sorted_params = sorted(params.items()) # 將 params 字典的項目轉換為 (key, value) 的列表並按 key 進行字母順序排序。 raw_str = \u0026#34;\u0026amp;\u0026#34;.join([f\u0026#34;{key}={value}\u0026#34; for key, value in sorted_params]) # 將排序後的參數列表轉換為 key=value 格式的字符串，並用 \u0026amp; 連接每一對參數。 raw_str = f\u0026#34;HashKey={hash_key}\u0026amp;{raw_str}\u0026amp;HashIV={hash_iv}\u0026#34; # 在拼接好的參數字符串前後分別添加 HashKey 和 HashIV。 encoded_str = urllib.parse.quote_plus(raw_str).lower() # URL 編碼並轉小寫，符合綠界規範 return hashlib.md5(encoded_str.encode(\u0026#34;utf-8\u0026#34;)).hexdigest().upper() # 計算 MD5 並轉為大寫 此函數用於加密請求參數，確保數據傳輸安全。\nparams: 要進行加密的參數字典（例如金流所需的交易資訊）。 raw_str = \u0026ldquo;\u0026amp;\u0026quot;.join([f\u0026rdquo;{key}={value}\u0026quot; for key, value in sorted_params]) 這行舉例： 如果參數是 {\u0026ldquo;Amount\u0026rdquo;: 100, \u0026ldquo;MerchantID\u0026rdquo;: \u0026ldquo;3002607\u0026rdquo;}，則結果是：\u0026ldquo;Amount=100\u0026amp;MerchantID=3002607\u0026rdquo;。\nraw_str = f\u0026quot;HashKey={hash_key}\u0026amp;{raw_str}\u0026amp;HashIV={hash_iv}\u0026quot; 這行舉例： 這是綠界金流的加密規範，確保生成的加密值與綠界伺服器的驗證邏輯一致。\n假設 HashKey 為 abc123，HashIV 為 xyz789，結果會是： \u0026ldquo;HashKey=abc123\u0026amp;Amount=100\u0026amp;MerchantID=3002607\u0026amp;HashIV=xyz789\u0026rdquo;。\nencoded_str = urllib.parse.quote_plus(raw_str).lower() 這行舉例： 假設原字符串為 HashKey=abc123\u0026amp;Amount=100\u0026amp;MerchantID=3002607\u0026amp;HashIV=xyz789，編碼後可能會變成： \u0026ldquo;hashkey%3Dabc123%26amount%3D100%26merchantid%3D3002607%26hashiv%3Dxyz789\u0026rdquo;\nreturn hashlib.md5(encoded_str.encode(\u0026ldquo;utf-8\u0026rdquo;)).hexdigest().upper() 這行舉例： 使用 Python 的 hashlib.md5 對編碼後的字符串進行 MD5 哈希計算。\n將結果轉換為 16 進位的哈希值（hexdigest），並轉為大寫。\n例如，MD5 計算後可能得到類似的結果：5F4DCC3B5AA765D61D8327DEB882CF99。\n3.4 建立訂單並生成金流參數 # 以下是實作 create_order 的詳細代碼，用於建立訂單並傳遞金流參數給前端：\n@login_required def create_order(request): if request.method == \u0026#34;POST\u0026#34;: service_id = request.POST.get(\u0026#34;service_id\u0026#34;) # 從前端獲取 service_id selected_plan = request.POST.get(\u0026#34;plan\u0026#34;) # 獲取前端傳入的方案 payment_method = request.POST.get(\u0026#34;payment_method\u0026#34;) # 獲取支付方式 service = get_object_or_404(Service, id=service_id) # 動態設置金額 if selected_plan == \u0026#34;standard\u0026#34;: total_price = service.standard_price elif selected_plan == \u0026#34;premium\u0026#34;: total_price = service.premium_price else: return JsonResponse({\u0026#34;error\u0026#34;: \u0026#34;Invalid plan selected.\u0026#34;}, status=400) valid_payment_methods = { \u0026#34;credit_card\u0026#34;: \u0026#34;Credit\u0026#34;, \u0026#34;atm\u0026#34;: \u0026#34;ATM\u0026#34;, \u0026#34;linepay\u0026#34;: \u0026#34;LinePay\u0026#34;,#等上線開通後才可啟用，測試環境不行 \u0026#34;googlepay\u0026#34;: \u0026#34;GooglePay\u0026#34;,#等上線開通後才可啟用，測試環境不行 \u0026#34;barcode\u0026#34;: \u0026#34;BARCODE\u0026#34;, } if payment_method not in valid_payment_methods: return JsonResponse( {\u0026#34;error\u0026#34;: \u0026#34;Invalid payment method selected.\u0026#34;}, status=400 ) # 建立訂單 order = request.user.orders_as_client.create( service=service, total_price=total_price, payment_method=payment_method, ) # 綠界金流參數 params = { \u0026#34;MerchantID\u0026#34;: MERCHANT_ID, \u0026#34;MerchantTradeNo\u0026#34;: order.merchant_trade_no, \u0026#34;MerchantTradeDate\u0026#34;: datetime.now().strftime(\u0026#34;%Y/%m/%d %H:%M:%S\u0026#34;), \u0026#34;PaymentType\u0026#34;: \u0026#34;aio\u0026#34;, \u0026#34;TotalAmount\u0026#34;: int(order.total_price), \u0026#34;TradeDesc\u0026#34;: \u0026#34;Payment for Order\u0026#34;, \u0026#34;ItemName\u0026#34;: f\u0026#34;Order {order.id}\u0026#34;, \u0026#34;ReturnURL\u0026#34;: request.build_absolute_uri(reverse(\u0026#34;order:ecpay_return\u0026#34;)), \u0026#34;OrderResultURL\u0026#34;: request.build_absolute_uri(reverse(\u0026#34;order:ecpay_result\u0026#34;)), \u0026#34;ChoosePayment\u0026#34;: valid_payment_methods[payment_method], } params[\u0026#34;CheckMacValue\u0026#34;] = generate_check_mac_value(params, HASH_KEY, HASH_IV) # 傳遞至前端表單 return render( request, \u0026#34;order/payment_form.html\u0026#34;, {\u0026#34;ecpay_url\u0026#34;: ECPAY_URL, \u0026#34;params\u0026#34;: params}, ) return JsonResponse({\u0026#34;error\u0026#34;: \u0026#34;Invalid request method.\u0026#34;}, status=405) 關鍵點解釋 # 動態金額設置：根據用戶選擇的方案計算訂單金額。 綠界金流參數：包含必要的金流數據（如 MerchantID、TotalAmount）。 驗證碼生成：通過 generate_check_mac_value 確保數據安全。 3.5 處理金流回傳結果 # 以下是處理金流回傳結果的函數 ecpay_return：\n@csrf_exempt # 允許跨站請求 def ecpay_return(request): if request.method == \u0026#34;POST\u0026#34;: data = request.POST.dict() # 獲取 POST 數據 check_mac = data.pop(\u0026#34;CheckMacValue\u0026#34;, None) # 提取 CheckMacValue if check_mac == generate_check_mac_value(data, HASH_KEY, HASH_IV): # 驗證 CheckMacValue merchant_trade_no = data.get(\u0026#34;MerchantTradeNo\u0026#34;) # 提取訂單編號 order_id = int(merchant_trade_no.replace(\u0026#34;ORDER\u0026#34;, \u0026#34;\u0026#34;)) # 從訂單編號中提取 ID order = get_object_or_404(Order, id=order_id) # 確保訂單存在 if data.get(\u0026#34;RtnCode\u0026#34;) == \u0026#34;1\u0026#34;: # 如果支付成功 order.status = \u0026#34;Paid\u0026#34; # 更新訂單狀態為已支付 order.save() # 保存訂單 return HttpResponse(\u0026#34;OK\u0026#34;) # 返回成功響應 return HttpResponse(\u0026#34;CheckMacValue Failed\u0026#34;) # 返回驗證失敗響應 解釋 # 數據驗證：通過比對 CheckMacValue 確保回傳數據未被篡改。 訂單狀態更新：根據金流結果更新訂單狀態。 3.6 處理金流結果頁面 # 以下是處理金流結果「成功」函數：\n@csrf_exempt # 允許跨站請求 def ecpay_result(request): return render(request, \u0026#34;order/order_successful.html\u0026#34;) # 渲染支付成功頁面 以下是處理金流結果「失敗」函數：\n@csrf_exempt def failed(request): return render(request, \u0026#34;order/order_failed.html\u0026#34;) # 渲染支付失敗頁面 本篇文章不會加入付款成功的畫面。可自行在 order/templates/order/order_successful.html 中添加想要的完成訂單畫面。\n亦不會加入付款失敗的畫面。可自行在 order/templates/order/order_failed.html 中添加想要的完成訂單畫面。\n3.7 自動提交的金流表單模板 # 在 order/templates/order/payment_form＿select.html，添加 payment_form_select.html 模板，快速將用戶導向綠界支付頁面：\n(此模板使用 Tailwind 樣式製作)\n\u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;{% url \u0026#39;order:create_order\u0026#39; %}\u0026#34;\u0026gt; {% csrf_token %} \u0026lt;!-- 隱藏的服務 ID --\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;service_id\u0026#34; value=\u0026#34;{{ service.id }}\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;plan\u0026#34; value=\u0026#34;{{ selected_plan }}\u0026#34;\u0026gt; \u0026lt;!-- 方案選擇 --\u0026gt; \u0026lt;div class=\u0026#34;mb-6\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;plan\u0026#34; class=\u0026#34;block mb-2 font-medium text-gray-900\u0026#34;\u0026gt;方案\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;plan\u0026#34; name=\u0026#34;plan\u0026#34; class=\u0026#34;w-full p-3 bg-white border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\u0026#34; onchange=\u0026#34;togglePlanView(this.value)\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;standard\u0026#34; {% if selected_plan == \u0026#34;standard\u0026#34; %}selected{% endif %}\u0026gt; 一般方案 \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;premium\u0026#34; {% if selected_plan == \u0026#34;premium\u0026#34; %}selected{% endif %}\u0026gt; 專業方案 \u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 支付方式 --\u0026gt; \u0026lt;div class=\u0026#34;mb-6\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;payment-method\u0026#34; class=\u0026#34;block mb-2 font-medium text-gray-900\u0026#34;\u0026gt;支付方式\u0026lt;/label\u0026gt; \u0026lt;select id=\u0026#34;payment_method\u0026#34; name=\u0026#34;payment_method\u0026#34; class=\u0026#34;w-full p-3 bg-white border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\u0026#34; \u0026gt; \u0026lt;option value=\u0026#34;\u0026#34; disabled selected\u0026gt;請選擇\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;credit_card\u0026#34;\u0026gt;信用卡(20萬以下)\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;atm\u0026#34;\u0026gt;ATM 轉帳(5萬以下)\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;linepay\u0026#34;\u0026gt;Line Pay\u0026lt;/option\u0026gt; {% comment %} \u0026lt;option value=\u0026#34;googlepay\u0026#34;\u0026gt;Google Pay\u0026lt;/option\u0026gt; {% endcomment %} \u0026lt;option value=\u0026#34;barcode\u0026#34;\u0026gt;超商條碼(2萬以下)\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 按鈕區域 --\u0026gt; \u0026lt;div class=\u0026#34;flex justify-between mb-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;px-4 py-2 font-semibold text-white bg-gray-400 rounded-lg hover:bg-gray-500 focus:outline-none focus:shadow-outline\u0026#34; onclick=\u0026#34;history.back();\u0026#34; \u0026gt; 上一步 \u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;px-4 py-2 font-semibold text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none focus:shadow-outline\u0026#34; id=\u0026#34;nextButton\u0026#34; disabled \u0026gt; 下一步 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 在 order/templates/order/payment_form.html，添加 payment_form.html 模板，快速將用戶導向綠界支付頁面：\n\u0026lt;form id=\u0026#34;ecpay_form\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;{{ ecpay_url }}\u0026#34;\u0026gt; {% for key, value in params.items %} \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;{{ key }}\u0026#34; value=\u0026#34;{{ value }}\u0026#34; /\u0026gt; {% endfor %} \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;ecpay_form\u0026#34;).submit(); // 自動提交表單 \u0026lt;/script\u0026gt; 3.8 設置模型 # 在實現功能之前，需要為 order 和 service 建立資料模型。以下是兩個應用的 models.py 內容：\norder/models.py\nfrom django.db import models from django.contrib.auth.models import User from services.models import Service import uuid from django.core.validators import MaxValueValidator, MinValueValidator class Order(models.Model): STATUS_CHOICES = [ (\u0026#34;pending\u0026#34;, \u0026#34;Pending\u0026#34;), (\u0026#34;paid\u0026#34;, \u0026#34;Paid\u0026#34;), (\u0026#34;completed\u0026#34;, \u0026#34;Completed\u0026#34;), (\u0026#34;cancelled\u0026#34;, \u0026#34;Cancelled\u0026#34;), ] #綠界支援多種支付方式 PAYMENT_METHOD_CHOICES = [ (\u0026#34;credit_card\u0026#34;, \u0026#34;Credit Card\u0026#34;),#金額(20萬以下) (\u0026#34;atm\u0026#34;, \u0026#34;ATM\u0026#34;), #金額(5萬以下) (\u0026#34;linepay\u0026#34;, \u0026#34;Line Pay\u0026#34;), #測試環境不支援 (\u0026#34;googlepay\u0026#34;, \u0026#34;Google Pay\u0026#34;), #測試環境不支援 (\u0026#34;barcode\u0026#34;, \u0026#34;Barcode\u0026#34;),#超商條碼金額(2萬以下) ] PLAN_CHOICES = [ (\u0026#34;standard\u0026#34;, \u0026#34;Standard\u0026#34;), (\u0026#34;premium\u0026#34;, \u0026#34;Premium\u0026#34;), ] # 用戶和服務關聯 client_user = models.ForeignKey( User, on_delete=models.CASCADE, related_name=\u0026#34;orders_as_client\u0026#34;, verbose_name=\u0026#34;客戶\u0026#34;, null=True, ) service = models.ForeignKey( Service, on_delete=models.SET_NULL, related_name=\u0026#34;orders\u0026#34;, verbose_name=\u0026#34;服務\u0026#34;, null=True, blank=True, ) # 訂單基本資訊 order_date = models.DateTimeField(auto_now_add=True, verbose_name=\u0026#34;訂單日期\u0026#34;) total_price = models.PositiveIntegerField( verbose_name=\u0026#34;總金額\u0026#34;, validators=[MinValueValidator(1), MaxValueValidator(9999999999)], ) status = models.CharField( max_length=50, choices=STATUS_CHOICES, default=\u0026#34;pending\u0026#34;, verbose_name=\u0026#34;訂單狀態\u0026#34;, ) # 支付相關欄位 payment_method = models.CharField( max_length=50, choices=PAYMENT_METHOD_CHOICES, verbose_name=\u0026#34;付款方式\u0026#34; ) merchant_trade_no = models.CharField( max_length=30, unique=True, null=True, blank=True, verbose_name=\u0026#34;商店訂單編號\u0026#34; ) selected_plan = models.CharField( max_length=20, choices=[(\u0026#34;standard\u0026#34;, \u0026#34;Standard\u0026#34;), (\u0026#34;premium\u0026#34;, \u0026#34;Premium\u0026#34;)], null=False, blank=False, verbose_name=\u0026#34;選擇方案\u0026#34;, ) class Meta: verbose_name = \u0026#34;訂單\u0026#34; verbose_name_plural = \u0026#34;訂單\u0026#34; def save(self, *args, **kwargs):#這是 Django 模型中的 save 方法，用於在將物件保存到資料庫時觸發。 if not self.merchant_trade_no: #檢查 merchant_trade_no 欄位是否為空（尚未設置）。 self.merchant_trade_no = f\u0026#34;ORDER{uuid.uuid4().hex[:12].upper()}\u0026#34;#生成一個唯一的商店訂單編號 (merchant_trade_no)。 super().save(*args, **kwargs)#super()：調用 Django 模型的原始 save 方法，確保自定義邏輯執行後仍能正常保存。 def __str__(self): service_title = ( self.service.title if self.service else \u0026#34;N/A\u0026#34; ) # 如果沒有服務，顯示 N/A return f\u0026#34;Order {self.merchant_trade_no} - {self.client_user.username} - {service_title}\u0026#34; self：指向當前模型的實例。 *args 和 **kwargs：允許該方法接受額外的參數，用於兼容 Django 的內建 save 方法的參數。 uuid.uuid4().hex[:12]：uuid.uuid4() 為生成隨機的 UUID（全球唯一標識），並取其前 12 位（字母和數字組成）。\n.hex：將 UUID 轉換為純 16 進位的字符串格式。 f\u0026quot;ORDER{\u0026hellip;}\u0026quot;：使用 Python 的格式化字符串（f-string）在生成的 UUID 前面加上固定的前綴 ORDER，表示這是訂單相關的代碼。 .upper()：將生成的字符串轉為大寫，統一格式。 MinValueValidator:\n確保輸入的值大於或等於指定的最小值。\n例如，用於確保價格或數量不低於某個值。 MaxValueValidator:\n確保輸入的值小於或等於指定的最大值。\n例如，用於限制數字不超過某個上限。 services/models.py\nfrom django.db import models from django.contrib.auth.models import User from categories.models import Category from utils.mixins import WebPImageModelMixin class Service(WebPImageModelMixin, models.Model): freelancer_user = models.ForeignKey( User, on_delete=models.CASCADE, related_name=\u0026#34;services\u0026#34;, null=True, ) category = models.ManyToManyField( Category, related_name=\u0026#34;services\u0026#34;, ) title = models.CharField(max_length=100) description = models.TextField() photo = models.ImageField(upload_to=\u0026#34;service_photos/\u0026#34;, blank=True, null=True) created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now=True) # 新增一般方案 standard_title = models.CharField(max_length=100) standard_description = models.TextField() standard_price = models.PositiveIntegerField() standard_delivery_time = models.PositiveIntegerField(null=True, blank=True) # 新增專業方案 premium_title = models.CharField(max_length=100, blank=True, null=True) premium_description = models.TextField(blank=True, null=True) premium_price = models.PositiveIntegerField(blank=True, null=True) premium_delivery_time = models.PositiveIntegerField(blank=True, null=True) rating = models.DecimalField( max_digits=2, decimal_places=1, null=True, blank=True, default=None, help_text=\u0026#34;Client rating for the service (e.g., 4.5 stars)\u0026#34;, ) def __str__(self): return self.title 3.9 遷移資料庫 # 在完成上述模型的定義後，執行以下命令生成並應用資料庫遷移檔：\npython manage.py makemigrations python manage.py migrate 四、測試環境提醒 # 測試環境參數僅適用於開發和測試。 確保在部署到生產環境前，將測試參數替換為正式環境參數。 測試交易不會扣款，但可以模擬完整支付流程。 4.1 切換至正式環境 # 在測試完成後，請確保切換至正式環境進行部署：\n更新金流參數：\n在 settings.py 或環境變數中更改參數為正式環境的值： MERCHANT_ID = \u0026#34;正式商店代號\u0026#34; HASH_KEY = \u0026#34;正式 Hash Key\u0026#34; HASH_IV = \u0026#34;正式 Hash IV\u0026#34; ECPAY_URL = \u0026#34;https://payment.ecpay.com.tw/Cashier/AioCheckOut/V5\u0026#34; 啟用 SSL： 綠界要求正式環境使用 HTTPS，確保伺服器已安裝 SSL 憑證。 確認回傳 URL： 在綠界金流平台上，設置正式的回傳 URL（ReturnURL 和 OrderResultURL），確保通知能正確到達。 測試交易： 使用少量金額進行測試交易，確認所有流程正常運作。 4.2 測試用例 # 模擬訂單創建：\n使用以下 URL 模擬訂單創建：\nhttp://127.0.0.1:8000/order/create/?service_id=1\u0026amp;plan=standard 檢查金流通知：\n使用 Postman 模擬綠界的回傳通知： 請求類型：POST URL: http://127.0.0.1:8000/order/return/ 請求數據：包含 MerchantTradeNo、RtnCode 和其他必要參數。 驗證狀態更新：\n在 Django 管理後台確認訂單的狀態是否正確更新為 Paid。 五、安全性提醒 # 5.1 安全性注意事項 # 保護敏感信息： 確保 HashKey 和 HashIV 僅存儲於伺服器的環境變數中。 避免在代碼庫中直接硬編碼。 避免濫用 @csrf_exempt： 僅在需要處理第三方請求（如金流回傳通知）時使用。 其他情況應保留 CSRF 保護機制。 僅允許可信來源（如綠界伺服器）的請求進入 ecpay_return 和 ecpay_result。 總結(測試卡號) # 通過上述步驟，即可成功完成在 Django 中串接綠界金流的全部流程！也可以透過測試環境輸入網址http://127.0.0.1:8000/order/create/確認是否成功。\n而測試環境一般信用卡測試卡號 :\n4311-9511-1111-1111 安全碼 : 任意輸入三碼數字 4311-9522-2222-2222 安全碼 : 任意輸入三碼數字 海外信用卡測試卡號 :\n4000-2011-1111-1111 安全碼 : 任意輸入三碼數字 參考資源：\n綠界測試資訊\n","date":"4 January 2025","externalUrl":null,"permalink":"/douoduublog/posts/django-%E4%B8%AD%E7%B6%A0%E7%95%8C%E9%87%91%E6%B5%81%E4%B8%B2%E6%8E%A5%E4%B9%8B%E8%A9%B3%E7%B4%B0%E5%AD%B8%E7%BF%92/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e金流功能是現代網站必不可少的商業化功能之一。本文中，將指導如何在 Django 框架中經由綠界金流完成支付功能的串接。最終將實現一個包括服務選擇、訂單管理和支付清算的完整流程。\u003c/p\u003e","title":"Django 中綠界金流串接之詳細學習","type":"posts"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/%E6%94%AF%E4%BB%98%E6%95%B4%E5%90%88/","section":"Tags","summary":"","title":"支付整合","type":"tags"},{"content":"","date":"4 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/%E7%B6%A0%E7%95%8C%E9%87%91%E6%B5%81/","section":"Tags","summary":"","title":"綠界金流","type":"tags"},{"content":"","date":"2 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"2 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":"前言 # 在團隊協作開發中，管理 Git 的 issues 和分支是一項至關重要的工作。為了讓流程更清晰，以下分為五大步驟，從開 issue 到完成合併，幫助團隊提升效率。\n流程概覽 # 以下是整體流程概覽：\n開 issue：記錄問題或功能需求。 建立分支：為每個 issue 建立獨立分支。 處理問題：修改程式碼，進行測試和提交。 提交 PR：將修改內容提交，進行審查。 合併分支：將 PR 合併至主分支。 一、開 issue # 在開發流程中，清晰地記錄問題或功能需求是第一步。通過 issue 開票功能，團隊可以明確開發目標，提升協作效率。\n1.1 命名規範 # 為了統一 issue 的命名方式，建議使用以下格式：\n類型 格式範例 用途 功能新增 [feat] 新增用戶登入功能 表示開發新功能。 問題修復 [fix] 修復按鈕樣式異常 表示修復 Bug 或程式錯誤。 文件更新 [docs] 更新 README 文件 表示文檔相關的更改。 重構代碼 [refactor] 優化數據處理邏輯 表示對代碼進行重構，但不改變功能。 測試相關 [test] 增加登入功能測試案例 表示添加或修改測試。 其他任務 [chore] 更新依賴項版本 表示其他例行任務，例如工具配置更新等。 1.2 步驟 # 描述問題或功能需求：輸入清晰的問題描述，例如「修正按鈕樣式」或「新增用戶驗證功能」。 附加相關連結：例如設計稿、需求文檔等，便於追蹤和查看詳情。 二、建立分支 # 每個 issue 都應該對應一個獨立的分支，以便進行隔離開發，確保主分支的穩定性。\n2.1 建立分支的命令 # git fetch origin git checkout -b issues/\u0026lt;issue編號\u0026gt; 範例 : # 假設建立編號為 14 的 issue 分支：\ngit fetch origin git checkout -b issues/14 三、處理 issue 時的 commit # 在處理問題的過程中，需要進行以下步驟：\n3.1 修改程式碼 # 針對 issue 的需求進行修改，並確保本地運行通過。\n3.2 提交 Commit # 使用規範化的 Commit 訊息，幫助團隊快速理解提交內容。\n常用 Commit 規範 : # 單字 用途 feat 新增功能 (feature)。 fix 修復問題或 Bug。 modify 修改現有內容，例如更新文件或調整功能。 test 增加或修改測試。 refactor 重構代碼，不改變功能。 chore 例行任務，例如更新依賴項或工具配置。 docs 文件相關，例如更新 README 或說明文檔。 範例 Commit # git add . git commit -m \u0026#34;fix: 修正按鈕樣式問題\u0026#34; 3.3 合併更新內容 # 如果需要將修改合併至上一個 Commit，可以使用：\ngit commit --amend --no-edit 四、提交 PR # 當完成 issue 的開發後，需要提交 Pull Request，邀請團隊成員進行程式碼審查。\n4.1 提交 PR 的步驟 # 提交修改到遠端分支： git push -u origin issues/\u0026lt;issue編號\u0026gt; 在 GitHub 平台建立 PR：填寫清晰的描述，並附上相關連結或是圖片，以便告知其他成員你處理的內容。\n通知團隊成員：\n在協作工具中 @團隊成員，請大家進行審查。\n範例通知：\n我提交了 PR，請大家查看！連結：[PR 連結]\n五、合併分支 # 在 Pull Request 通過審查後，可以將分支合併到主分支。\n5.1 合併前操作 # 確保主分支內容最新： git pull origin main 合併分支： git merge issues/\u0026lt;issue編號\u0026gt; 刪除分支（可選）： git branch -d issues/\u0026lt;issue編號\u0026gt; 5.2 解決衝突 # 若在合併分支時遇到衝突，可按照以下步驟處理：\n查看衝突文件，手動修改衝突內容。 修改完成後，使用以下命令標記衝突已解決： git add \u0026lt;文件名\u0026gt; 如果使用 git rebase，執行以下命令繼續： git rebase --continue 如果使用 git merge，衝突解決後合併會自動完成。 5.3 推送合併後的更新 # 合併完成後，記得將最新的內容推送到遠端：\ngit push origin main 或推送到其他遠端分支：\ngit push origin \u0026lt;分支名稱\u0026gt; 總結 # 這篇文章從開 issue 到提交 PR、合併分支，完整介紹了 Git 團隊協作的基本流程，並提供了相關命令與範例，希望能幫助你提升工作效率！\n","date":"2 January 2025","externalUrl":null,"permalink":"/douoduublog/posts/%E9%AB%98%E6%95%88%E7%AE%A1%E7%90%86-git-issues-%E5%92%8C%E5%88%86%E6%94%AF%E5%BE%9E%E9%96%8B%E7%A5%A8%E5%88%B0-pr-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在團隊協作開發中，管理 Git 的 issues 和分支是一項至關重要的工作。為了讓流程更清晰，以下分為五大步驟，從開 issue 到完成合併，幫助團隊提升效率。\u003c/p\u003e","title":"高效管理 Git Issues 和分支：從開票到 PR 的完整流程","type":"posts"},{"content":"","date":"1 January 2025","externalUrl":null,"permalink":"/douoduublog/tags/ngrok/","section":"Tags","summary":"","title":"Ngrok","type":"tags"},{"content":"前言 # 這篇教學針對新手，將以簡單易懂的方式，教您如何在 Mac 的 VSCode 終端機 中，使用 Ngrok 來分享 Django 專案。\nNgrok 是一個非常實用的工具，可以快速將本地服務分享至外部網絡，適用於 API 測試、Webhook 回調或遠端開發。本篇也會提供可能遇到的問題及解決方法，讓您能順利完成操作。\n一、什麼是 Ngrok？ # 1.1 Ngrok 是什麼？ # Ngrok 是一款強大的內網穿透工具，可將本地開發環境映射為可從外部訪問的網址，無需進行繁瑣的伺服器設定。它適用於：\n測試 API：無需將程式部署到線上環境，即可供測試。 展示本地專案：可將開發中的網站分享給團隊或客戶。 Webhook 回調：用於接收第三方服務的請求，進行開發與調試。 1.2 主要功能簡介 # 內網穿透：快速將本地服務轉換為外部網址。 即時流量監控：檢視請求的詳細資訊，方便開發調試。 高級功能（付費版）：支援自訂域名、TLS 加密等進階功能。 二、安裝和設置 Ngrok # 2.1 安裝 Ngrok # (a) 安裝 Homebrew（如果尚未安裝） # 在 VSCode 的終端機中執行以下指令來安裝 Homebrew：\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 驗證 Homebrew 是否安裝成功：\nbrew --version (b) 使用 Homebrew 安裝 Ngrok # 安裝 Ngrok：\nbrew install ngrok 驗證安裝是否成功：\nngrok version 2.2 註冊與認證 Ngrok # (a) 註冊帳戶 # 前往 Ngrok 官網 註冊免費帳戶。 (b) 獲取認證碼 # 登入後，在控制台找到您的 authtoken。 (c) 在終端機中認證 # 在 VSCode 終端機執行： ngrok authtoken \u0026lt;您的認證碼\u0026gt; 認證成功後，Ngrok 即可正常使用。\n三、啟動 Ngrok（以 Django 為例） # 3.1 啟動 Django 開發伺服器 # 進入 Django 專案目錄，啟動伺服器：\npython manage.py runserver 此時，伺服器會運行在 http://127.0.0.1:8000。\n3.2 啟動 Ngrok # 在另一個終端機視窗執行：\nngrok http 8000 Ngrok 啟動後，您會看到類似以下的輸出：\nForwarding https://abc123.ngrok.io -\u0026gt; http://127.0.0.1:8000 3.3 訪問專案 # 複製 https://abc123.ngrok.io，在瀏覽器中開啟，即可透過外部網絡訪問 Django 專案。 團隊或客戶可直接透過該網址進行測試。 四、常見問題與解決方法 # 4.1 常見問題 # 無法分享網址：請確保 Django 伺服器已成功啟動，並確認埠號配置正確。 認證失敗：請確認輸入的 authtoken 無誤。 4.2 解決方法 # 重啟服務：重新啟動 Django 開發伺服器與 Ngrok。 升級版本：確保 Ngrok 是最新版本。 檢查網路：確保網路穩定，避免 Ngrok 無法正常運行。 五、進階功能介紹 # 5.1 自訂域名（付費功能） # 若使用付費版 Ngrok，可設定自訂域名：\nngrok http -hostname=custom.yourdomain.com 8000 5.2 即時流量監控 # Ngrok 提供本地監控介面，允許開發者檢視所有進入隧道的請求詳情，幫助偵錯與分析流量模式。\n在瀏覽器中輸入： http://127.0.0.1:4040 可檢視請求 Headers、Payload 等細節。 六、Django 相關設定建議 # 6.1 允許外部連接 # 在 settings.py 設定 ALLOWED_HOSTS：\nALLOWED_HOSTS = [\u0026#39;127.0.0.1\u0026#39;, \u0026#39;.ngrok.io\u0026#39;] 6.2 調整 Debug 模式 # 確保 DEBUG = True 以便在開發環境中正常使用 Ngrok，避免請求被 Django 的安全設定攔截：\nDEBUG = True 七、Ngrok 與其他工具比較 # 除了 Ngrok，還有其他內網穿透工具可供選擇，以下是三種常見工具的簡要比較：\n工具 免註冊 自訂域名 連線穩定性 適用場景 LocalTunnel ✅ ❌ 較低 短期測試 API、簡單展示 Expose ❌ ✅ 中等 需要自訂域名與免費 SSL Ngrok ❌ ✅（付費） 高 長期穩定應用、Webhook 測試 選擇建議：\n短期測試：使用 LocalTunnel，快速建立臨時測試環境。 需要自訂域名：選擇 Expose，免費支援 SSL，適合展示應用。 穩定性與進階功能：Ngrok 提供強大監控與 CI/CD 整合，適合長期專案。 八、結論 # Ngrok 是一款功能強大的內網穿透工具，適用於各種開發需求，特別是在 API 測試、Webhook 回調與遠端開發等場景。透過本文的教學，你應該已經掌握了如何 安裝、認證、使用 Ngrok，並了解了它與其他工具的比較。\n如果你的需求只是 短期測試或臨時展示，LocalTunnel 可能是更快的選擇；如果需要 穩定的連線與監控功能，Ngrok 依然是最佳方案。\n希望這篇教學能幫助你更順利地使用 Ngrok，提升開發效率！🚀\n","date":"1 January 2025","externalUrl":null,"permalink":"/douoduublog/posts/%E6%96%B0%E6%89%8B%E5%BF%85%E5%82%99ngrok-%E8%A9%B3%E7%9B%A1%E6%95%99%E5%AD%B8%E6%8C%87%E5%8D%97/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e這篇教學針對新手，將以簡單易懂的方式，教您如何在 \u003cstrong\u003eMac 的 VSCode 終端機\u003c/strong\u003e 中，使用 Ngrok 來分享 Django 專案。\u003c/p\u003e","title":"新手必備：Ngrok 詳盡教學指南","type":"posts"},{"content":"","date":"21 December 2024","externalUrl":null,"permalink":"/douoduublog/tags/line/","section":"Tags","summary":"","title":"Line","type":"tags"},{"content":"前言 # 在這篇文章中，將詳細介紹如何在 Django 項目中實現 LINE 登入功能。我們會使用 django-allauth 這個強大的第三方庫，讓開發者可以輕鬆集成各種社交平台的登入功能。\nLINE 是一款流行的即時通訊軟體，它的開放平台為開發者提供了方便的 API，讓用戶可以使用 LINE 賬號快速登入網站或應用程式。對於需要快速提升用戶體驗的網站來說，社交登入是非常重要的功能。\n本文的目標是幫助開發者從零到有，實現一個支持 LINE 登入的 Django 項目，並涵蓋完整的流程與實現細節。\n流程圖 # [用戶點擊登入按鈕] ↓ [跳轉到 LINE 授權頁面] ↓ [用戶授權成功] ↓ [回調到 Django URL 並處理授權碼] ↓ [完成登入，跳轉到指定頁面] 一、環境準備 # 在開始之前，確保你已經準備好以下環境：\n1 、安裝 Python 3.6 或更高版本。\n2 、安裝並設定 Django（推薦版本 3.2 或更高）。\n3 、熟悉基本的 Django 配置與開發流程。\n此外，確保你已註冊 LINE Developers 賬號，因為稍後我們需要配置 LINE 的開發者平台。\n二、註冊 LINE 開發者賬號並創建應用 # 1、 登錄 LINE Developers。\n2、 創建一個新的 Channel：\n點擊 Create a new provider，填寫應用名稱。\n在 Channels 中選擇 Create a Messaging API channel 或 Create a Web App（此處我們選 Web App）。\n3、 獲取 Channel ID 與 Channel Secret：\nChannel ID：稍後配置為 client_id。\nChannel Secret：稍後配置為 secret。\n4、 配置 LINE Developers 中增加回調 URL：\n在 LINE 開發者平台的應用設置中，找到 Callback URL。 https://yourdomain.com/accounts/line/login/callback/ 如果在本地測試，可以使用工具如 ngrok，生成臨時的 HTTPS URL。\n或是像我作為測試環境使用:\nhttp://127.0.0.1:8000/accounts/line/login/callback/ 5、在根目錄增加 URL\npath(\u0026#34;accounts/\u0026#34;, include(\u0026#34;allauth.urls\u0026#34;)) 三、安裝必要的依賴 # 3.1 安裝 django-allauth # pip install django-allauth 若是使用 poetry 環境，則輸入：\npoetry add django-allauth 四、配置 Django # 4.1 添加應用到 INSTALLED_APPS # # 在 settings.py 中添加應用 INSTALLED_APPS += [ \u0026#34;django.contrib.sites\u0026#34;, # 支持多站點功能，是 django-allauth 的依賴 \u0026#34;allauth\u0026#34;, # django-allauth 主框架 \u0026#34;allauth.account\u0026#34;, # 提供帳號註冊、登入等功能 \u0026#34;allauth.socialaccount\u0026#34;, # 支持社交平台登入 \u0026#34;allauth.socialaccount.providers.line\u0026#34;, # LINE 登入的支持 ] # 設置站點 ID，對應 Django sites 框架中的主站點 SITE_ID = 1 django.contrib.sites：Django 的多站點框架，django-allauth 必需。\nallauth.socialaccount.providers.line：啟用 LINE 作為登入提供者。\n4.2 配置 LINE 提供者 # 在 settings.py 中，添加 LINE 的社交登入配置：\nfrom dotenv import load_dotenv import os # 加載環境變量（來自 .env 文件） load_dotenv() SOCIALACCOUNT_PROVIDERS = { \u0026#34;line\u0026#34;: { \u0026#34;APP\u0026#34;: { \u0026#34;client_id\u0026#34;: os.getenv(\u0026#34;LINE_CLIENT_ID\u0026#34;),# 從環境變量中讀取 LINE Channel ID \u0026#34;secret\u0026#34;: os.getenv(\u0026#34;LINE_SECRET\u0026#34;),# 從環境變量中讀取 LINE Channel Secret \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, }, \u0026#34;SCOPE\u0026#34;: [\u0026#34;profile\u0026#34;, \u0026#34;openid\u0026#34;, \u0026#34;email\u0026#34;],# 要求的權限範圍：用戶資料、開放身份和電子郵件 \u0026#34;AUTH_PARAMS\u0026#34;: {\u0026#34;response_type\u0026#34;: \u0026#34;code\u0026#34;}, # 授權類型：使用授權碼 }, } 將 LINE 憑據存儲到 .env 文件中：\nLINE_CLIENT_ID = 你的LINE Channel ID LINE_SECRET = 你的LINE Channel Secret 4.3 配置登錄與跳轉 # 在 settings.py 中，配置登入和跳轉路徑：\n# 配置登入和跳轉的 URL LOGIN_URL = \u0026#34;/users/login/\u0026#34; # 用戶未登錄時重定向的登錄頁面 LOGIN_REDIRECT_URL = \u0026#34;/\u0026#34; # 登錄成功後的重定向頁面 ACCOUNT_SIGNUP_REDIRECT_URL = \u0026#34;/\u0026#34; # 註冊成功後的重定向頁面 SOCIALACCOUNT_LOGIN_ON_GET = True # 點擊登入按鈕後立即跳轉到 LINE 授權頁面 LOGIN_URL ：未登錄用戶被重定向的路徑。\nLOGIN_REDIRECT_URL ：登錄成功後的跳轉地址。\nSOCIALACCOUNT_LOGIN_ON_GET ：用戶點擊登入後直接跳轉授權頁面，無需額外操作。\n五、運行數據庫遷移 # 啟用 sites 框架和社交賬號的數據模型：\npython manage.py migrate 此命令應在終端中執行，用於創建 django-allauth 和 django.contrib.sites 所需的數據表。 確保所有配置和應用已正確添加到 INSTALLED_APPS 中。 六、添加登入按鈕 # 在網站的模板檔案中，使用 django-allauth 提供的模板標籤生成 LINE 登入按鈕：\n\u0026lt;!--templates/login.html--\u0026gt; \u0026lt;a href=\u0026#34;{% provider_login_url \u0026#39;line\u0026#39; %}\u0026#34;\u0026gt;Login with LINE\u0026lt;/a\u0026gt; 這段代碼使用了 django-allauth 的模板標籤，生成 LINE 登入的 URL。當用戶點擊後，將被重定向到 LINE 的授權頁面。\n七、測試登入流程 # 7.1 測試授權 # 1、啟動本地開發伺服器：\npython manage.py runserver 2、打開瀏覽器，訪問 /users/login/，點擊 Login with LINE。\n3、你將被重定向到 LINE 的授權頁面，允許訪問後返回網站。\n7.2 獲取用戶數據 # 如果需要使用授權後的用戶資料，可以通過 SocialAccount 模型獲取：\n#views.py from allauth.socialaccount.models import SocialAccount # 獲取當前登錄用戶的 LINE 資料 def user_profile(request): user = request.user if user.is_authenticated: # 查詢 LINE 的 SocialAccount 資料 social_account = SocialAccount.objects.filter(user=user, provider=\u0026#39;line\u0026#39;).first() if social_account: line_profile = social_account.extra_data # 包含 LINE 用戶信息 return JsonResponse(line_profile) # 返回用戶資料作為 JSON 響應 return HttpResponse(\u0026#34;Not logged in.\u0026#34;) # 如果未登錄，返回提示 SocialAccount 模型用於存儲來自社交平臺的用戶數據。 該視圖會返回當前用戶的 LINE 資料或提示未登錄。 八、部署到生產環境 # 在生產環境中部署時，需注意：\n1、 使用 HTTPS：LINE 要求回調 URL 必須是 HTTPS。\n2、 正確配置域名：確保在 LINE 開發者平台的 Callback URL 與你的站點域名一致。\n3、 隱藏敏感信息：通過 .env 文件或環境變量存儲 client_id 和 secret。\n8.1 在部署時的配置內容 # 以下是使用 zeabur 部署時增加的內容\n在 settings.py 中添加：\nLINE_CALLBACK_URL = os.getenv( \u0026#34;LINE_CALLBACK_URL\u0026#34;, \u0026#34;http://localhost:8000/accounts/line/login/callback/\u0026#34; ) SECURE_PROXY_SSL_HEADER = (\u0026#34;HTTP_X_FORWARDED_PROTO\u0026#34;, \u0026#34;https\u0026#34;) CSRF_TRUSTED_ORIGINS = [ \u0026#34;https://trico.zeabur.app\u0026#34;, \u0026#34;http://127.0.0.1:8000\u0026#34;, ] ALLOWED_HOSTS = [ \u0026#34;127.0.0.1\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;*\u0026#34;, ] 在.env中配置：\nLINE_CALLBACK_URL=https://trico.zeabur.app/accounts/line/login/callback/ 在 LINE Developers 的 Callback URL 中加入以下內容，一個是你的測試環境，一個是你部署的網址\nhttp://127.0.0.1:8000/accounts/line/login/callback/ https://trico.zeabur.app/accounts/line/login/callback/ 注意！！！ 不可以加逗號 九、結語 # 這樣應該已經成功實現了 LINE 登入功能！\ndjango-allauth 不僅支持 LINE，還可以輕鬆集成其他社交平台（如綁定多個賬號、用戶資料同步，像是 Google、Facebook 等）。\n可以進一步探索其 API，實現更多功能，如用戶資料同步、綁定多個社交賬號等，讓網站更加實用。\n參考資源：\ndjango-allauth 官方文檔\nLINE_Developers 平台\n","date":"21 December 2024","externalUrl":null,"permalink":"/douoduublog/posts/%E5%A6%82%E4%BD%95%E5%9C%A8-django-%E4%B8%AD%E5%AF%A6%E7%8F%BE-line-%E7%99%BB%E5%85%A5%E5%8A%9F%E8%83%BD/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在這篇文章中，將詳細介紹如何在 Django 項目中實現 LINE 登入功能。我們會使用 django-allauth 這個強大的第三方庫，讓開發者可以輕鬆集成各種社交平台的登入功能。\u003c/p\u003e","title":"如何在 Django 中實現 LINE 登入功能","type":"posts"},{"content":"","date":"21 December 2024","externalUrl":null,"permalink":"/douoduublog/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E9%87%91%E6%B5%81/","section":"Tags","summary":"","title":"第三方金流","type":"tags"},{"content":"","date":"2 December 2024","externalUrl":null,"permalink":"/douoduublog/tags/vue.js/","section":"Tags","summary":"","title":"Vue.js","type":"tags"},{"content":"前言 # 本篇文章適合 Vue.js 初學者，將帶你快速了解 Vue.js 的基礎指令、事件處理、迴圈應用，並示範如何搭建專案環境。透過本篇教學，你將能夠寫出 Vue.js 的基礎應用，並進一步理解 Vue 的核心概念。\n一、Vue.js 基本概念 # 1.1 Vue.js 指令與響應式資料 # Vue 指令 (v- 開頭)：Vue 使用 v- 作為指令前綴，例如 v-model、v-bind 等。 響應式變數 (ref)：使用 ref 定義變數，Vue 會自動追蹤其變更，並即時更新畫面。 不需直接操作 DOM：Vue 自動處理 UI 更新，開發者無需使用 document.querySelector 來手動抓取 DOM 元素。 1.2 Vue.js 基本範例 # 以下是 Vue.js 的 Hello World 範例，使用 ref 定義響應式變數 msg，並讓輸入框綁定到變數。\n點擊練習網址\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const msg = ref(\u0026#34;Hello World!\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; \u0026lt;input v-model=\u0026#34;msg\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 二、事件處理 # 2.1 v-model (表單綁定) # v-model 用於雙向綁定輸入框與變數，適用於表單元素，例如 input、textarea。\n\u0026lt;input v-model=\u0026#34;msg\u0026#34; /\u0026gt; 2.2 v-on 事件綁定 (縮寫 @) # Vue 事件處理可使用 v-on 綁定，縮寫為 @。\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const msg = ref(\u0026#34;Hello Vue!\u0026#34;); const updateMessage = (event) =\u0026gt; { msg.value = event.target.value; }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input @input=\u0026#34;updateMessage\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 2.3 設定條件樣式 # 可透過 v-bind:class 動態設定 CSS，以下範例當字數超過 15 時，文字變紅色。\n\u0026lt;template\u0026gt; \u0026lt;h1 :class=\u0026#34;{ red: msg.length \u0026gt; 15 }\u0026#34;\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .red { color: red; } \u0026lt;/style\u0026gt; 三、迴圈渲染 # 3.1 v-for 迴圈渲染 # v-for 可用於渲染陣列內容，以下範例遍歷 products 陣列。\n點題練習網址\n\u0026lt;script setup\u0026gt; const products = [ { title: \u0026#34;北歐風簡約餐椅\u0026#34;, price: 1290 }, { title: \u0026#34;無線藍牙耳機\u0026#34;, price: 2490 }, ]; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;item in products\u0026#34; :key=\u0026#34;item.title\u0026#34;\u0026gt; \u0026lt;div\u0026gt;名稱: {{ item.title }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;價格: {{ item.price }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 四、Vue.js 開發環境搭建 # 4.1 建立 Vue.js 專案 # 在終端機執行以下指令來初始化 Vue.js 專案。\nnpm init vue@latest my-vue-app cd my-vue-app npm install 4.2 啟動開發伺服器 # npm run dev 成功執行後，終端機將顯示開發伺服器的網址，例如 http://localhost:5173/。\n五、Vue.js 主應用程式 (main.js) # Vue 應用程式的入口檔案為 main.js，createApp 負責初始化應用。\nimport { createApp } from \u0026#34;vue\u0026#34;; import App from \u0026#34;./App.vue\u0026#34;; createApp(App).mount(\u0026#34;#app\u0026#34;); 六、結論 # 透過本篇教學，你已經學會了 Vue.js 的 指令、事件處理、迴圈渲染，並成功搭建 Vue.js 專案環境。Vue.js 讓開發者能夠更專注於應用邏輯，而不必直接操作 DOM，讓開發更直觀且高效。\n如果你對 Vue.js 有興趣，建議繼續學習 元件化開發、Vue Router、Vuex (Pinia) 等進階主題，進一步提升你的開發能力！🚀\n","date":"2 December 2024","externalUrl":null,"permalink":"/douoduublog/posts/vue.js-%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80%E6%8C%87%E5%8D%97/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本篇文章適合 Vue.js 初學者，將帶你快速了解 \u003cstrong\u003eVue.js 的基礎指令、事件處理、迴圈應用\u003c/strong\u003e，並示範如何搭建專案環境。透過本篇教學，你將能夠寫出 Vue.js 的基礎應用，並進一步理解 Vue 的核心概念。\u003c/p\u003e","title":"Vue.js 基礎入門指南","type":"posts"},{"content":"前言 # Git 是目前最流行的版本控制系統之一，幫助開發者管理專案變更、追蹤歷史紀錄，並與團隊協作。本篇文章將整理 Git 的常用指令，並提供 如何上傳到 GitHub 以及 練習 Git 指令的小遊戲，適合 Git 初學者學習與進階使用。\n分支切錯換名字就好了！！！！！分支就是個貼紙而已 一、安裝 VSCode 擴充功能 # 在 VSCode 中可以安裝 Git Graph 擴充功能，幫助你在終端機底部可視化歷史紀錄。\n二、Git 常用指令 # 這些指令可以幫助你在 Git 進行版本控制、管理分支及解決問題。\n# 查看 Git 內建指令的使用方式 $ git help commit # 刪除暫存區中的檔案 $ git restore --staged \u0026lt;file\u0026gt; # 查看歷史紀錄（卡住時可按 Q 退出） $ git log # 切換到指定 commit（較舊的方式，可能會影響其他內容） $ git checkout \u0026lt;commit編號\u0026gt; # 還原被刪除的檔案 $ git restore \u0026lt;file\u0026gt; # 查看當前分支 $ git branch # 新增分支 $ git branch \u0026lt;分支名稱\u0026gt; # 恢復被刪除的分支（需提供 commit 編號） $ git branch \u0026lt;分支名稱\u0026gt; \u0026lt;commit編號\u0026gt; # 切換分支 $ git switch \u0026lt;分支名稱\u0026gt; # 合併分支 $ git merge \u0026lt;分支名稱\u0026gt; # 強制建立合併紀錄 $ git merge \u0026lt;分支名稱\u0026gt; --no-ff -m \u0026#39;merge\u0026#39; # 查看檔案修改歷史（誰寫的） $ git blame \u0026lt;檔案名稱\u0026gt; # 重新整理提交歷史（會改變 commit 記錄） $ git rebase \u0026lt;分支名稱\u0026gt; 2.1 Merge vs. Rebase（合併與重寫提交歷史） # Merge（合併）：適合多人協作，會保留完整的 commit 歷史，讓所有更改紀錄可追溯。 Rebase（重寫歷史）：適合個人開發，會將 commit 整合到一條線上，使提交歷史更乾淨整潔。 📌 何時使用？\n團隊開發：使用 Merge，確保團隊成員的 commit 紀錄完整。 個人開發：使用 Rebase，確保歷史紀錄乾淨，不影響主分支。 2.2 解決合併衝突 # 使用 Merge 時發生衝突，修改檔案後執行： git add . git commit -m \u0026#34;解決合併衝突\u0026#34; 使用 Rebase 時發生衝突，修改檔案後執行： git add \u0026lt;檔案\u0026gt; git rebase --continue 三、Git 版本控制與重置 # # 重置 commit（預設 mixed） $ git reset \u0026lt;commit編號\u0026gt; --mixed # 將變更保留在工作目錄 $ git reset \u0026lt;commit編號\u0026gt; --soft # 保留變更於暫存區 $ git reset \u0026lt;commit編號\u0026gt; --hard # 直接刪除變更 # 回到上一個 commit（HEAD^ = 倒退一步，HEAD~2 = 倒退兩步） $ git reset HEAD^ $ git reset HEAD~2 # 查看最近的 commit 移動紀錄 $ git reflog # 硬重置回指定 commit $ git reset \u0026lt;commit編號\u0026gt; --hard # 取得遠端最新的變更，並合併到本地分支 $ git pull origin main # 相當於 git fetch + git merge # 複製遠端專案 $ git clone \u0026lt;GitHub倉庫網址\u0026gt; 四、Git 練習小遊戲 # 透過互動式小遊戲來熟悉 Git 分支管理：Git 練習遊戲\n五、GitHub 操作指南 # 5.1 上傳專案 # 若要將本地專案上傳至 GitHub，請先在 GitHub 建立新倉庫，然後執行以下步驟：\n# 初始化 Git $ git init # 查看當前狀態 $ git status # 新增檔案至暫存區（. 代表全部） $ git add . # 提交變更 $ git commit -m \u0026#34;First commit\u0026#34; # 設定 main 為預設分支 $ git branch -M main # 連結遠端倉庫 $ git remote add origin \u0026lt;GitHub 倉庫網址\u0026gt; # 推送至 GitHub $ git push -u origin main 5.2 更新專案內容 # 若要在 GitHub 更新專案內容，請使用以下指令：\n$ git status # 檢查變更 $ git add . # 加入變更 $ git commit -m \u0026#34;更新內容\u0026#34; $ git push # 推送到 GitHub 推送後，可在 GitHub 倉庫的 Actions 確認上傳狀態，等待更新完成即可。\n六、總結 # Git 幫助管理程式碼版本，提升開發效率。 學習 Git 指令能讓你更好地掌控專案，並有效管理團隊協作。 透過 GitHub，可輕鬆儲存、分享與部署你的程式碼。 希望這篇文章能幫助你更熟悉 Git，開始你的版本控制之旅！🚀\n","date":"29 November 2024","externalUrl":null,"permalink":"/douoduublog/posts/%E9%97%9C%E6%96%BCgit%E7%9A%84%E5%B8%B8%E8%A6%8B%E6%8C%87%E4%BB%A4/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eGit 是目前最流行的版本控制系統之一，幫助開發者管理專案變更、追蹤歷史紀錄，並與團隊協作。本篇文章將整理 \u003cstrong\u003eGit 的常用指令\u003c/strong\u003e，並提供 \u003cstrong\u003e如何上傳到 GitHub\u003c/strong\u003e 以及 \u003cstrong\u003e練習 Git 指令的小遊戲\u003c/strong\u003e，適合 Git 初學者學習與進階使用。\u003c/p\u003e","title":"Git 常見指令整理","type":"posts"},{"content":"","date":"23 November 2024","externalUrl":null,"permalink":"/douoduublog/tags/crud/","section":"Tags","summary":"","title":"CRUD","type":"tags"},{"content":"","date":"23 November 2024","externalUrl":null,"permalink":"/douoduublog/tags/restful-api/","section":"Tags","summary":"","title":"RESTful API","type":"tags"},{"content":"前言 # RESTful API 是一種設計方式，讓不同的應用程式能夠透過網路互相溝通。它使用標準的 HTTP 方法（如 GET、POST、PUT、DELETE）來存取和管理資源，使得前端和後端可以更容易地分工合作。\n這篇文章將簡單介紹 RESTful API 的基本概念、設計原則，並說明它如何與 CRUD（Create、Read、Update、Delete）操作相對應，幫助新手更容易理解並開始使用 RESTful API。\n一、RESTful API 介紹 # RESTful API 是一種基於 REST (Representational State Transfer) 架構風格的 Web API 設計方式。其核心思想是透過統一的資源接口（URI）來操作資源，並使用標準的 HTTP 方法（如 GET、POST、PUT、DELETE）進行通信。\nRESTful API 被廣泛應用於 前後端分離架構，使前端（如 Web 或手機應用）能與後端服務透過標準化接口進行交互。\n二、RESTful API 的核心概念 # RESTful API 的設計遵循一些核心概念，讓 API 更容易理解和使用，確保 API 結構清晰、易於維護。\n統一的資源路徑 (URI)\n每個資源（如「用戶」或「文章」）都有固定的網址，例如： GET /users：取得所有用戶 POST /users：新增用戶 使用標準的 HTTP 方法來操作資源\nRESTful API 遵循 HTTP 標準，透過不同的方法來對資源進行操作： GET：獲取資源，如 GET /users 來取得所有用戶。 POST：新增資源，如 POST /users 來新增用戶。 PUT：更新資源，如 PUT /users/1 來修改 ID 為 1 的用戶。 DELETE：刪除資源，如 DELETE /users/1 來移除 ID 為 1 的用戶。 這些方法讓 API 更具一致性，使開發者能夠輕鬆理解和使用。 RESTful API 使用 GET、POST、PUT、DELETE 等 HTTP 方法來操作資源。 請求與回應格式\nAPI 一般使用 JSON 來傳遞資料，因為它簡單易讀。 無狀態性 (Statelessness)\n每個請求都是獨立的，伺服器不會記住上一個請求的狀態。 可擴展與靈活性\nAPI 設計應該允許未來擴充，例如 GET /users?limit=10 來限制回傳的用戶數量。 這些概念有助於 RESTful API 變得更具可讀性、可擴展性，並讓不同系統之間的溝通變得更加順暢。\n三、HTTP 方法與資源操作 # RESTful API 通常使用 HTTP 方法 來執行資源操作，對應如下：\nHTTP 方法 操作 用途 GET 讀取 獲取單個或多個資源。 POST 創建 在資源集合下新增一個資源。 PUT 更新 （整體替換） 更新整個資源。 PATCH 更新 （部分更新） 僅更新資源的部分字段。 DELETE 刪除 移除指定資源。 四、HTTP 狀態碼 # RESTful API 通過 HTTP 狀態碼 來表示請求結果：\n狀態碼 含義 200 成功 (GET、PUT、DELETE 成功)。 201 創建成功 (POST 成功)。 204 無內容 (DELETE 成功且無返回內容)。 400 壞請求 (請求格式錯誤)。 401 未授權 (需要身份驗證)。 404 找不到資源。 500 服務器內部錯誤。 五、CRUD 與數據操作 # CRUD（Create、Read、Update、Delete）是數據操作的基本概念，對應於應用內部的數據管理。\n操作 SQL 對應 ORM 對應（如 Django ORM） Create INSERT INTO .create() Read SELECT .all()、.filter() Update UPDATE .update() Delete DELETE .delete() 六、RESTful API 設計與 CRUD 對應 # HTTP 方法 RESTful API 功能 CRUD 動作 範例 POST 新增資源 Create 新增一筆用戶數據 GET 讀取資源 Read 獲取所有用戶或單個用戶 PUT 更新整個資源 Update 更新用戶資料 PATCH 部分更新資源 Update 更新部分用戶資料 DELETE 刪除資源 Delete 刪除一筆用戶數據 七、CRUD 與 RESTful API 的區別 # 特性 CRUD RESTful API 概念 針對數據的操作方法 一種 Web API 設計風格 技術 主要與數據庫操作相關 基於 HTTP 協議的資源操作 應用 用於內部系統邏輯處理 用於客戶端與伺服器之間的通信 數據存取 直接對接數據庫 透過 API 來存取資源 八、總結 # CRUD 是應用內部 數據管理 的基本操作。 RESTful API 是 對外提供接口 的設計風格，基於 HTTP 協議。 兩者關聯：CRUD 為內部邏輯，RESTful API 則透過標準 HTTP 方法對外暴露資源。 透過理解 CRUD 和 RESTful API 的概念，開發者能夠更好地設計 Web 應用程式，並提升 API 的可維護性與擴展性。\n希望這篇文章能幫助你更好地掌握 RESTful API 與 CRUD 的關鍵概念！ 🚀\n","date":"23 November 2024","externalUrl":null,"permalink":"/douoduublog/posts/restful-api%E8%88%87crud/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eRESTful API 是一種設計方式，讓不同的應用程式能夠透過網路互相溝通。它使用標準的 \u003cstrong\u003eHTTP 方法\u003c/strong\u003e（如 GET、POST、PUT、DELETE）來存取和管理資源，使得前端和後端可以更容易地分工合作。\u003c/p\u003e","title":"RESTful API 與 CRUD","type":"posts"},{"content":"","date":"23 November 2024","externalUrl":null,"permalink":"/douoduublog/tags/vscode/","section":"Tags","summary":"","title":"VSCode","type":"tags"},{"content":"前言 # Visual Studio Code（VSCode）是一款功能強大且廣受開發者喜愛的程式碼編輯器。透過快捷鍵，開發者可以更高效地編輯程式碼、管理視窗與控制終端機，提高工作效率。\n本篇文章整理了 VSCode 常用的快捷鍵，幫助開發者熟悉基本操作，提升開發體驗。\n官方完整快捷鍵文件：VSCode 官方文件\n一、常用快捷鍵 # 這些快捷鍵可用於開啟檔案、設定環境及管理 VSCode 介面。\nCtrl+Shift+P 或 F1 # 開啟命令面板，快速執行指令 Ctrl+P 或 Ctrl+E # 快速開啟最近使用的檔案 Ctrl+Shift+N # 開啟新的 VSCode 視窗 Ctrl+Shift+W # 關閉目前的 VSCode 視窗 Ctrl+, # 開啟設定（Preferences） Ctrl+K Ctrl+S # 打開鍵盤快捷鍵設定 Control+` (Backtick) # 開啟/關閉終端機 二、編輯快捷鍵 # 這些快捷鍵可以幫助你快速進行程式碼編輯，提高編碼效率。\nCtrl+X # 剪下當前行（即使未選取內容） Ctrl+C # 複製當前行（即使未選取內容） Alt+ ↑ / ↓ # 移動當前行到上/下方 (Alt = Option on macOS) Shift+Alt+ ↑ / ↓ # 複製當前行到上/下方 Ctrl+Shift+K # 刪除當前行 Ctrl+Enter # 在當前行下方插入新行 Ctrl+Shift+Enter # 在當前行上方插入新行 Home / End # 移動到行首或行尾 Ctrl+Home / Ctrl+End # 移動到文件的頂部或底部 Ctrl+↑ / ↓ # 向上/向下滾動單行 Alt+PgUp / PgDn # 向上/向下滾動一整頁 Ctrl+K Ctrl+0 # 收合所有程式碼區塊 Ctrl+K Ctrl+J # 展開所有程式碼區塊 Ctrl+K Ctrl+C # 轉換選取內容為單行註解 Ctrl+K Ctrl+U # 解除單行註解 Ctrl+/ # 切換單行註解 Shift+Alt+A # 切換區域註解 Alt+Z # 切換自動換行模式 Command+D # 選取下一個相同的字串 三、終端機（Console）快捷鍵 # 這些快捷鍵可用於 VSCode 內建終端機（Console）進行快速操作。\nControl+W # 刪除當前游標前的一個單詞 Control+U # 刪除當前行 Control+R # 搜尋命令歷史紀錄 Control+L # 清除終端機畫面 四、總結 # 熟悉並靈活運用這些快捷鍵，可以大幅提升 VSCode 的操作效率。建議新手先掌握基本快捷鍵，並在開發過程中逐步適應更多高效操作。\n希望這篇文章能幫助你更高效地使用 VSCode！🚀\n","date":"23 November 2024","externalUrl":null,"permalink":"/douoduublog/posts/vscode-%E5%BF%AB%E6%8D%B7%E9%8D%B5%E5%A4%A7%E5%85%A8/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eVisual Studio Code（VSCode）是一款功能強大且廣受開發者喜愛的程式碼編輯器。透過快捷鍵，開發者可以更高效地編輯程式碼、管理視窗與控制終端機，提高工作效率。\u003c/p\u003e","title":"VSCode 快捷鍵大全","type":"posts"},{"content":"前言 # 安裝 Django、MTV 模式中的 Template (T) 與 View (V) 實作練習。\n本篇文章將介紹如何使用 Django 建立一個 about 頁面。\n首先，先分享完整ＣＲＵＤ流程!!!\n本篇文章將實作 T (Template) 和 V (View) 的部分。 一、MVC 與 MTV 模式簡介 # 1.1 MVC（Model-View-Controller） # M（Model，模型）：負責與資料庫交互，執行 CRUD（新增、讀取、更新、刪除）。 V（View，視圖）：負責處理業務邏輯並渲染頁面。 C（Controller，控制器）：處理 Request、Response，管理 Model 與 View 之間的交互。 1.2 MTV（Model-Template-View） # Django 採用 MTV 模式，概念上類似 MVC，但有所區別：\nM（Model）：與 MVC 的 Model 相同。 T（Template）：負責前端頁面（HTML、CSS、JavaScript）。 V（View）：負責處理請求並回傳適當的模板頁面。 Django 的 Controller 角色由框架本身處理。 二、安裝 Django 並建立專案 # 2.1 使用 Poetry 安裝 Django # 建議使用 Poetry 來建立虛擬環境並安裝 Django。\npoetry new myproject cd myproject poetry add django 注意：確保 app 資料夾 必須放在 專案根目錄，並寫入 settings.py 的 INSTALLED_APPS 內。\n2.2 建立 Django 專案 # django-admin startproject pydev . 注意：最後的 . 代表將專案初始化在目前目錄。\n2.3 設定專案 URL # 在 pydev/urls.py 中新增路由：\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#34;admin/\u0026#34;, admin.site.urls), path(\u0026#34;\u0026#34;, include(\u0026#34;pages.urls\u0026#34;)), ] include(\u0026quot;pages.urls\u0026quot;) 允許我們將應用程式的 URL 組織到單獨的 urls.py 檔案。\n三、建立 about 頁面 # 3.1 建立 pages 應用程式 # python manage.py startapp pages 在 pages/ 內建立 以下結構：\npages/ │── migrations/ │── templates/ │ └── pages/ │ └── about.html │── views.py │── urls.py 3.2 設定 pages/urls.py # from django.urls import path from pages.views import about urlpatterns = [ path(\u0026#34;about/\u0026#34;, about), ] 3.3 設定 pages/views.py # from django.shortcuts import render def about(request): return render(request, \u0026#34;pages/about.html\u0026#34;) 3.4 建立 about.html # 建立 pages/templates/pages/about.html：\n{% extends \u0026#34;shared/layout.html\u0026#34; %} {% block content %} \u0026lt;h1\u0026gt;About\u0026lt;/h1\u0026gt; {% endblock %} 3.5 建立 layout.html # 建立 templates/shared/layout.html：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;My Django App\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {% block content %}{% endblock %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：必須確保 settings.py 中 TEMPLATES 設定的 DIRS 內包含 templates/ 目錄，否則無法找到 layout.html。\nTEMPLATES = [ { \u0026#34;BACKEND\u0026#34;: \u0026#34;django.template.backends.django.DjangoTemplates\u0026#34;, \u0026#34;DIRS\u0026#34;: [\u0026#34;templates\u0026#34;], \u0026#34;APP_DIRS\u0026#34;: True, \u0026#34;OPTIONS\u0026#34;: {...}, }, ] 四、啟動伺服器並測試 # python manage.py runserver 打開瀏覽器，訪問 http://127.0.0.1:8000/about/，應該可以看到 about 頁面。\n五、Django 註解語法 # {% comment %} 這是一個 Django 註解 {% endcomment %} Django 使用 Django Template Language (DTL)，雖然語法類似 Jinja2，但實際上是 Django 獨有的模板語言。\n六、結論 # 本篇文章示範了 如何使用 Django 建立一個簡單的 about 頁面，並介紹了 MTV 模式中的 Template (T) 與 View (V)。\n重點回顧：\n使用 Poetry 安裝 Django 並建立專案。 建立 Django 應用程式 pages 並新增路由與視圖。 使用 render 方法回傳 HTML 模板。 設定 layout.html 讓多個頁面共用模板結構。 希望這篇文章能幫助你更快掌握 Django 的基本概念！🚀\n","date":"22 November 2024","externalUrl":null,"permalink":"/douoduublog/posts/%E4%BD%BF%E7%94%A8django%E5%81%9A%E4%B8%80%E5%80%8B%E9%A0%81%E9%9D%A2/","section":"文章","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e安裝 Django、MTV 模式中的 Template (T) 與 View (V) 實作練習。\u003c/p\u003e\n\u003cp\u003e本篇文章將介紹如何使用 Django 建立一個 \u003ccode\u003eabout\u003c/code\u003e 頁面。\u003c/p\u003e","title":"使用 Django 建立一個頁面","type":"posts"},{"content":"","date":"17 November 2024","externalUrl":null,"permalink":"/douoduublog/tags/%E7%92%B0%E5%A2%83%E5%AE%89%E8%A3%9D/","section":"Tags","summary":"","title":"環境安裝","type":"tags"},{"content":" 前言 # 在進入 Python 領域之前，建議先安裝相關工具與套件，這樣可以邊學習邊實作，提高學習效率。本篇文章將介紹 Python 環境安裝的各種方式，適用於 macOS 使用者。\n一、安裝 Python # 首先，需要從 Python 官網下載並安裝最新版本，安裝完成後可進行以下步驟確認安裝是否成功。\n1.1 在終端機輸入以下指令： # which python3 # 檢查 Python3 位置 python3 # 進入 Python 互動模式（REPL） exit() 或 按 Control+D # 離開 Python 環境 二、了解 REPL 環境 # REPL（Read-Eval-Print-Loop） 是 Python 內建的交互式執行環境。\n在這個環境底下會讀取輸入的指令，然後評估是否可執行。\n如果可以就把結果印出來，不行就會出現錯誤的訊息。\n最後不管能不能執行，都會進入下一個指令的迴圈。\n讀取（Read）：讀取使用者輸入的指令。 評估（Eval）：執行輸入的指令。 輸出（Print）：印出執行結果。 循環（Loop）：回到下一個指令輸入。 適合進行 簡單測試 或 程式驗證。 三、安裝 pyenv # pyenv 是什麼：pyenv 是一款管理 多個 Python 版本 的工具，可以輕鬆切換不同版本。\n3.1 安裝 pyenv # 請參考官方文件：pyenv 官方安裝指南\n3.2 常用指令 # 在終端機輸入以下內容，並分別為：\nwhich pyenv # 確認 pyenv 位置 pyenv #出現指令 pyenv -v # 查看 pyenv 版本 pyenv install --list # 列出可安裝的 Python 版本 pyenv install 3.12.4 # 安裝指定版本，可下載最新的 pyenv global 3.12.4 # 設定預設 Python 版本，此時就可以隨意打python不用加3 pyenv versions # 列出已安裝的 Python 版本 pyenv shell 3.12.4 #若沒改成預設值，可以用叫的叫出這個版本 四、安裝 VS Code # 安裝後可透過快捷鍵提升開發效率。\n4.1 常用快捷鍵 # Command+Shift+P # 開啟命令面板 Control+` # 開啟終端機 Command+D # 選取下一個相同項目 Option+Shift+↓ # 複製整行 Command+/ # 註解/取消註解 直接再游標那行按複製 #可貼上到任一游標處 Option+游標處＋上下鍵 #可移動整行 五、執行第一個 Python 程式 # 5.1 使用內建終端機 # cd 資料夾名稱 # 切換到目標資料夾 ls -al # 查看資料夾內容 python3 檔案名稱.py # 執行 Python 程式，例如：python3 hi.py 5.2 在 VS Code 執行 # pwd # 確認當前目錄 python3 檔案名稱.py # 執行 Python 程式，例如：python3 hi.py 六、安裝 Python 套件 # 6.1 使用 pip 安裝套件 # 先到 PyPI 的網站，例如要下載 request 套件，搜尋 request。\n複製指令到 Vscode 的終端機安裝。\npip install requests # 安裝 requests 套件 pip uninstall requests # 卸載 requests (但不會全部刪掉，會有混雜的套件留存，造成空間浪費) pip list # 查看已安裝的套件 七、建立虛擬環境（venv） # 目的：不會影響其他專案，因為同樣套件只能安裝一個版本，所以沒加會覆蓋。\n7.1 建立虛擬環境 # 以下內容-m 是指載入，venv 是內建虛擬模組，myenv 是自己取的虛擬環境名字\npython -m venv myenv # 建立名為 myenv 的虛擬環境 python -m venv myenv --prompt=\u0026#34;hello\u0026#34; #如同上述，不過這行--prompt=\u0026#34;自己取名字\u0026#34;，為Vscode開啟終端機時「名稱」會變hello 7.2 啟動虛擬環境 # 左側欄位會出現一個 myenv 資料夾，裡面有一些資料夾，在使用虛擬環境時，不太管它。但啟動虛擬環境，裡面有一個 bin 資料夾，底下有 activate，執行輸入。\nsource myenv/bin/activate # 啟動虛擬環境 7.3 在虛擬環境內安裝套件 # pip install django # 安裝 Django pip list #若要看內容，領域展開，輸入以上 pip freeze \u0026gt; requirements.txt # 產生套件清單 pip install -r requirements.txt # 依據套件清單安裝 7.4 停用虛擬環境 # deactivate # 離開虛擬環境 八、使用 Poetry 進行套件管理 # Poetry 是一款現代化的 Python 套件管理工具，提供 安裝、版本控制、打包與發布 等功能。\n8.1 安裝 Poetry # pip install poetry # 安裝 Poetry 8.2 初始化或安裝 Poetry 專案 # 8.2.1 建立新專案 # 如果是全新的專案，可以使用 poetry new 來建立專案目錄，並自動生成 pyproject.toml：\npoetry new myproject # 建立新專案 cd myproject # 進入專案目錄 pwd #確認輸入位置沒錯 8.2.2 在現有專案初始化 Poetry # 如果你已經有一個資料夾，並希望使用 Poetry 來管理它，請執行：\ncd existing_project # 進入現有專案目錄 poetry init # 初始化 Poetry，建立 pyproject.toml 8.2.3 安裝專案依賴 # 當 pyproject.toml 檔案已經存在時（無論是透過 poetry new 或 poetry init 建立），使用以下指令來安裝所有依賴：\npoetry install # 根據 pyproject.toml 安裝所有依賴，創一個.venv資料夾 8.3 使用 Poetry 管理套件 # poetry shell #先切換到虛擬目錄裡面，在poetry執行 poetry add requests # 安裝套件，例如套件名稱為requests poetry remove requests # 移除 requests 套件，或是可以刪掉資料夾 pip list #看內容 poetry show #可以看裝的套件及版本資訊（較詳細） poetry show --tree # 查看依賴樹狀結構 poetry add pre-commit --group dev #裝到不同群組裡佈置時使用 poetry env info #看poetry位置裝到哪 poetry env remove 位置 #刪除指定位置虛擬環境 poetry cofing --list #檢查內容 九、語意化版本控制 # 在 pyproject.toml 內使用 語意化版本規則 來管理依賴。\n\u0026#34;^5.0.3\u0026#34; # ^是中間數字0有跳動，會自動抓到新版本，是部分更動，升級中間的版本 \u0026#34;~5.0.3\u0026#34; # 允許修正版本更新，但不變更次要版本，~是3有跳動，只裝這個後面的，算是小地方更動 \u0026#34;\u0026gt;=5.0.3\u0026#34; # 安裝 5.0.3 以上的版本，只要大於等於這個版本就安裝 \u0026#34;==5.0.3\u0026#34; # 僅安裝 5.0.3，不升級，這個就好！ 結論 # 本篇文章介紹了 Python 環境安裝、套件管理、虛擬環境與 VS Code 使用技巧，這些概念是學習 Python 及 Django 等框架的重要基礎。\n學習重點回顧：\npyenv 可用於管理多版本 Python。 venv 和 Poetry 讓專案環境更獨立。 pip 和 Poetry 幫助管理 Python 套件。 VS Code 提供便利的開發工具與快捷鍵。 希望這篇文章能幫助你順利開始 Python 開發旅程！\n","date":"17 November 2024","externalUrl":null,"permalink":"/douoduublog/posts/%E7%92%B0%E5%A2%83%E5%AE%89%E8%A3%9D-%E8%B8%8F%E5%85%A5python%E7%AC%AC%E4%B8%80%E6%AD%A5/","section":"文章","summary":"\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在進入 Python 領域之前，建議先安裝相關工具與套件，這樣可以邊學習邊實作，提高學習效率。本篇文章將介紹 Python 環境安裝的各種方式，適用於 \u003cstrong\u003emacOS 使用者\u003c/strong\u003e。\u003c/p\u003e","title":"環境安裝 - 踏入 Python 第一步","type":"posts"},{"content":"hi！我是小瑜 # 歡迎來到我的部落格◍•ᴗ•◍ 這邊主要分享一些攝影、旅遊、網頁學習等內容！ 以下是我的簡介\n自我介紹 # 我是個平面接案攝影師，曾任苗栗縣政府文化觀光局特約攝影師，我拍攝過學生各類服裝設計及棚內拍攝、婚禮攝影、商品攝影、時裝走秀，並且經常在台北時裝週出沒，喜好拍攝時尚、服裝類型，目前有認識的團隊是拍攝動態影片，有拍過廣告、MV、短影音等，經驗豐富，歡迎聯繫！\n另外，我曾經是個高鐵站務員，因為對科技業充滿好奇而離開。有到補習班學習全端程式設計，所以這邊也會分享一些菜鳥學習的內容，主要是我本身是個熱愛分享事物的人，所以創了這個 Blog 分享！若有任何問題歡迎聯繫。\n一、攝影服務 # 平面攝影 # 婚禮攝影 食物攝影 商品攝影 動態攝影 # 婚禮錄影 ＭＶ 廣告拍攝 短影音拍攝 二、軟體學習 # 前端 # Html/Css JavaScript HTMX Tailwind Vue 後端 # Python Django C# .NET 其他 # PostgreSQL Git 版本控制 GitHub 聯繫方式 # Email : selinafs880504@gmail.com 電話 : 0978-076262 GitHub : 連結 YouTube : 連結 ","date":"17 November 2024","externalUrl":null,"permalink":"/douoduublog/about/","section":"小瑜的部落格","summary":"\u003ch1 class=\"relative group\"\u003ehi！我是小瑜 \n    \u003cdiv id=\"hi%E6%88%91%E6%98%AF%E5%B0%8F%E7%91%9C\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#hi%E6%88%91%E6%98%AF%E5%B0%8F%E7%91%9C\" aria-label=\"定位點\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cimg src=\"img/小魚.jpg\" alt=\"me\" width=\"500px\"\u003e\n\u003ch3 style=\"color:#91B493\"\u003e\u003cstrong\u003e歡迎來到我的部落格◍•ᴗ•◍ \u003c/strong\u003e\u003c/h3\u003e\n這邊主要分享一些攝影、旅遊、網頁學習等內容！\n\u003cp style=\"color:#9B90C2 ; text-decoration:underline;\" \u003e\u003ca href=\"#me\"\u003e\u003cem\u003e以下是我的簡介\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e","title":"about this blog","type":"page"},{"content":"","externalUrl":null,"permalink":"/douoduublog/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]